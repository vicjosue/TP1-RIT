PERLAPI(1)       Perl Programmers Reference Guide      PERLAPI(1)



NNAAMMEE
       perlapi - autogenerated documentation for the perl public
       API

DDEESSCCRRIIPPTTIIOONN
       This file contains the documentation of the perl public
       API generated by embed.pl, specifically a listing of func­
       tions, macros, flags, and variables that may be used by
       extension writers.  The interfaces of any functions that
       are not listed here are subject to change without notice.
       For this reason, blindly using functions listed in proto.h
       is to be avoided when writing extensions.

       Note that all Perl API global variables must be referenced
       with the "PL_" prefix.  Some macros are provided for com­
       patibility with the older, unadorned names, but this sup­
       port may be disabled in a future release.

       The listing is alphabetical, case insensitive.

       AvFILL  Same as "av_len()".  Deprecated, use "av_len()"
               instead.

                       int     AvFILL(AV* av)


       av_clear
               Clears an array, making it empty.  Does not free
               the memory used by the array itself.

                       void    av_clear(AV* ar)


       av_delete
               Deletes the element indexed by "key" from the
               array.  Returns the deleted element. "flags" is
               currently ignored.

                       SV*     av_delete(AV* ar, I32 key, I32 flags)


       av_exists
               Returns true if the element indexed by "key" has
               been initialized.

               This relies on the fact that uninitialized array
               elements are set to "&PL_sv_undef".

                       bool    av_exists(AV* ar, I32 key)


       av_extend
               Pre-extend an array.  The "key" is the index to
               which the array should be extended.

                       void    av_extend(AV* ar, I32 key)


       av_fetch
               Returns the SV at the specified index in the
               array.  The "key" is the index.  If "lval" is set
               then the fetch will be part of a store.  Check
               that the return value is non-null before derefer­
               encing it to a "SV*".

               See the Understanding the Magic of Tied Hashes and
               Arrays entry in the perlguts manpage for more
               information on how to use this function on tied
               arrays.

                       SV**    av_fetch(AV* ar, I32 key, I32 lval)


       av_fill Ensure than an array has a given number of ele­
               ments, equivalent to Perl's "$#array = $fill;".

                       void    av_fill(AV* ar, I32 fill)


       av_len  Returns the highest index in the array.  Returns
               -1 if the array is empty.

                       I32     av_len(AV* ar)


       av_make Creates a new AV and populates it with a list of
               SVs.  The SVs are copied into the array, so they
               may be freed after the call to av_make.  The new
               AV will have a reference count of 1.

                       AV*     av_make(I32 size, SV** svp)


       av_pop  Pops an SV off the end of the array.  Returns
               "&PL_sv_undef" if the array is empty.

                       SV*     av_pop(AV* ar)


       av_push Pushes an SV onto the end of the array.  The array
               will grow automatically to accommodate the addi­
               tion.

                       void    av_push(AV* ar, SV* val)


       av_shift
               Shifts an SV off the beginning of the array.

                       SV*     av_shift(AV* ar)


       av_store
               Stores an SV in an array.  The array index is
               specified as "key".  The return value will be NULL
               if the operation failed or if the value did not
               need to be actually stored within the array (as in
               the case of tied arrays). Otherwise it can be
               dereferenced to get the original "SV*".  Note that
               the caller is responsible for suitably increment­
               ing the reference count of "val" before the call,
               and decrementing it if the function returned NULL.

               See the Understanding the Magic of Tied Hashes and
               Arrays entry in the perlguts manpage for more
               information on how to use this function on tied
               arrays.

                       SV**    av_store(AV* ar, I32 key, SV* val)


       av_undef
               Undefines the array.  Frees the memory used by the
               array itself.

                       void    av_undef(AV* ar)


       av_unshift
               Unshift the given number of "undef" values onto
               the beginning of the array.  The array will grow
               automatically to accommodate the addition.  You
               must then use "av_store" to assign values to these
               new elements.

                       void    av_unshift(AV* ar, I32 num)


       bytes_from_utf8
               Converts a string "s" of length "len" from UTF8
               into byte encoding.  Unlike <utf8_to_bytes> but
               like "bytes_to_utf8", returns a pointer to the
               newly-created string, and updates "len" to contain
               the new length.  Returns the original string if no
               conversion occurs, "len" is unchanged. Do nothing
               if "is_utf8" points to 0. Sets "is_utf8" to 0 if
               "s" is converted or contains all 7bit characters.

               NOTE: this function is experimental and may change
               or be removed without notice.

                       U8*     bytes_from_utf8(U8 *s, STRLEN *len, bool *is_utf8)


       bytes_to_utf8
               Converts a string "s" of length "len" from ASCII
               into UTF8 encoding.  Returns a pointer to the
               newly-created string, and sets "len" to reflect
               the new length.

               NOTE: this function is experimental and may change
               or be removed without notice.

                       U8*     bytes_to_utf8(U8 *s, STRLEN *len)


       call_argv
               Performs a callback to the specified Perl sub.
               See the perlcall manpage.

               NOTE: the perl_ form of this function is depre­
               cated.

                       I32     call_argv(const char* sub_name, I32 flags, char** argv)


       call_method
               Performs a callback to the specified Perl method.
               The blessed object must be on the stack.  See the
               perlcall manpage.

               NOTE: the perl_ form of this function is depre­
               cated.

                       I32     call_method(const char* methname, I32 flags)


       call_pv Performs a callback to the specified Perl sub.
               See the perlcall manpage.

               NOTE: the perl_ form of this function is depre­
               cated.

                       I32     call_pv(const char* sub_name, I32 flags)


       call_sv Performs a callback to the Perl sub whose name is
               in the SV.  See the perlcall manpage.

               NOTE: the perl_ form of this function is depre­
               cated.

                       I32     call_sv(SV* sv, I32 flags)


       CLASS   Variable which is setup by "xsubpp" to indicate
               the class name for a C++ XS constructor.  This is
               always a "char*".  See "THIS".

                       char*   CLASS


       Copy    The XSUB-writer's interface to the C "memcpy"
               function.  The "src" is the source, "dest" is the
               destination, "nitems" is the number of items, and
               "type" is the type.  May fail on overlapping
               copies.  See also "Move".

                       void    Copy(void* src, void* dest, int nitems, type)


       croak   This is the XSUB-writer's interface to Perl's
               "die" function.  Normally use this function the
               same way you use the C "printf" function.  See
               "warn".

               If you want to throw an exception object, assign
               the object to "$@" and then pass "Nullch" to
               croak():

                  errsv = get_sv("@", TRUE);
                  sv_setsv(errsv, exception_object);
                  croak(Nullch);

                       void    croak(const char* pat, ...)


       CvSTASH Returns the stash of the CV.

                       HV*     CvSTASH(CV* cv)


       dMARK   Declare a stack marker variable, "mark", for the
               XSUB.  See "MARK" and "dORIGMARK".

                               dMARK;


       dORIGMARK
               Saves the original stack mark for the XSUB.  See
               "ORIGMARK".

                               dORIGMARK;


       dSP     Declares a local copy of perl's stack pointer for
               the XSUB, available via the "SP" macro.  See "SP".

                               dSP;


       dXSARGS Sets up stack and mark pointers for an XSUB, call­
               ing dSP and dMARK.  This is usually handled auto­
               matically by "xsubpp".  Declares the "items" vari­
               able to indicate the number of items on the stack.

                               dXSARGS;


       dXSI32  Sets up the "ix" variable for an XSUB which has
               aliases.  This is usually handled automatically by
               "xsubpp".

                               dXSI32;


       ENTER   Opening bracket on a callback.  See "LEAVE" and
               the perlcall manpage.

                               ENTER;


       eval_pv Tells Perl to "eval" the given string and return
               an SV* result.

               NOTE: the perl_ form of this function is depre­
               cated.

                       SV*     eval_pv(const char* p, I32 croak_on_error)


       eval_sv Tells Perl to "eval" the string in the SV.

               NOTE: the perl_ form of this function is depre­
               cated.

                       I32     eval_sv(SV* sv, I32 flags)


       EXTEND  Used to extend the argument stack for an XSUB's
               return values. Once used, guarantees that there is
               room for at least "nitems" to be pushed onto the
               stack.

                       void    EXTEND(SP, int nitems)


       fbm_compile
               Analyses the string in order to make fast searches
               on it using fbm_instr() -- the Boyer-Moore algo­
               rithm.

                       void    fbm_compile(SV* sv, U32 flags)




       fbm_instr
               Returns the location of the SV in the string
               delimited by "str" and "strend".  It returns
               "Nullch" if the string can't be found.  The "sv"
               does not have to be fbm_compiled, but the search
               will not be as fast then.

                       char*   fbm_instr(unsigned char* big, unsigned char* bigend, SV* littlesv, U32 flags)


       FREETMPS
               Closing bracket for temporaries on a callback.
               See "SAVETMPS" and the perlcall manpage.

                               FREETMPS;


       get_av  Returns the AV of the specified Perl array.  If
               "create" is set and the Perl variable does not
               exist then it will be created.  If "create" is not
               set and the variable does not exist then NULL is
               returned.

               NOTE: the perl_ form of this function is depre­
               cated.

                       AV*     get_av(const char* name, I32 create)


       get_cv  Returns the CV of the specified Perl subroutine.
               If "create" is set and the Perl subroutine does
               not exist then it will be declared (which has the
               same effect as saying "sub name;").  If "create"
               is not set and the subroutine does not exist then
               NULL is returned.

               NOTE: the perl_ form of this function is depre­
               cated.

                       CV*     get_cv(const char* name, I32 create)


       get_hv  Returns the HV of the specified Perl hash.  If
               "create" is set and the Perl variable does not
               exist then it will be created.  If "create" is not
               set and the variable does not exist then NULL is
               returned.

               NOTE: the perl_ form of this function is depre­
               cated.

                       HV*     get_hv(const char* name, I32 create)


       get_sv  Returns the SV of the specified Perl scalar.  If
               "create" is set and the Perl variable does not
               exist then it will be created.  If "create" is not
               set and the variable does not exist then NULL is
               returned.

               NOTE: the perl_ form of this function is depre­
               cated.

                       SV*     get_sv(const char* name, I32 create)


       GIMME   A backward-compatible version of "GIMME_V" which
               can only return "G_SCALAR" or "G_ARRAY"; in a void
               context, it returns "G_SCALAR".  Deprecated.  Use
               "GIMME_V" instead.

                       U32     GIMME


       GIMME_V The XSUB-writer's equivalent to Perl's "wantar­
               ray".  Returns "G_VOID", "G_SCALAR" or "G_ARRAY"
               for void, scalar or list context, respectively.

                       U32     GIMME_V


       GvSV    Return the SV from the GV.

                       SV*     GvSV(GV* gv)


       gv_fetchmeth
               Returns the glob with the given "name" and a
               defined subroutine or "NULL".  The glob lives in
               the given "stash", or in the stashes accessible
               via @ISA and @UNIVERSAL.

               The argument "level" should be either 0 or -1.  If
               "level==0", as a side-effect creates a glob with
               the given "name" in the given "stash" which in the
               case of success contains an alias for the subrou­
               tine, and sets up caching info for this glob.
               Similarly for all the searched stashes.

               This function grants ""SUPER"" token as a postfix
               of the stash name. The GV returned from "gv_fetch­
               meth" may be a method cache entry, which is not
               visible to Perl code.  So when calling "call_sv",
               you should not use the GV directly; instead, you
               should use the method's CV, which can be obtained
               from the GV with the "GvCV" macro.

                       GV*     gv_fetchmeth(HV* stash, const char* name, STRLEN len, I32 level)


       gv_fetchmethod
               See the gv_fetchmethod_autoload manpage.

                       GV*     gv_fetchmethod(HV* stash, const char* name)


       gv_fetchmethod_autoload
               Returns the glob which contains the subroutine to
               call to invoke the method on the "stash".  In fact
               in the presence of autoloading this may be the
               glob for "AUTOLOAD".  In this case the correspond­
               ing variable $AUTOLOAD is already setup.

               The third parameter of "gv_fetchmethod_autoload"
               determines whether AUTOLOAD lookup is performed if
               the given method is not present: non-zero means
               yes, look for AUTOLOAD; zero means no, don't look
               for AUTOLOAD.  Calling "gv_fetchmethod" is equiva­
               lent to calling "gv_fetchmethod_autoload" with a
               non-zero "autoload" parameter.

               These functions grant ""SUPER"" token as a prefix
               of the method name. Note that if you want to keep
               the returned glob for a long time, you need to
               check for it being "AUTOLOAD", since at the later
               time the call may load a different subroutine due
               to $AUTOLOAD changing its value. Use the glob cre­
               ated via a side effect to do this.

               These functions have the same side-effects and as
               "gv_fetchmeth" with "level==0".  "name" should be
               writable if contains "':'" or "' ''". The warning
               against passing the GV returned by "gv_fetchmeth"
               to "call_sv" apply equally to these functions.

                       GV*     gv_fetchmethod_autoload(HV* stash, const char* name, I32 autoload)


       gv_stashpv
               Returns a pointer to the stash for a specified
               package.  "name" should be a valid UTF-8 string.
               If "create" is set then the package will be cre­
               ated if it does not already exist.  If "create" is
               not set and the package does not exist then NULL
               is returned.

                       HV*     gv_stashpv(const char* name, I32 create)


       gv_stashsv
               Returns a pointer to the stash for a specified
               package, which must be a valid UTF-8 string.  See
               "gv_stashpv".

                       HV*     gv_stashsv(SV* sv, I32 create)


       G_ARRAY Used to indicate list context.  See "GIMME_V",
               "GIMME" and the perlcall manpage.

       G_DISCARD
               Indicates that arguments returned from a callback
               should be discarded.  See the perlcall manpage.

       G_EVAL  Used to force a Perl "eval" wrapper around a call­
               back.  See the perlcall manpage.

       G_NOARGS
               Indicates that no arguments are being sent to a
               callback.  See the perlcall manpage.

       G_SCALAR
               Used to indicate scalar context.  See "GIMME_V",
               "GIMME", and the perlcall manpage.

       G_VOID  Used to indicate void context.  See "GIMME_V" and
               the perlcall manpage.

       HEf_SVKEY
               This flag, used in the length slot of hash entries
               and magic structures, specifies the structure con­
               tains a "SV*" pointer where a "char*" pointer is
               to be expected. (For information only--not to be
               used).

       HeHASH  Returns the computed hash stored in the hash
               entry.

                       U32     HeHASH(HE* he)


       HeKEY   Returns the actual pointer stored in the key slot
               of the hash entry. The pointer may be either
               "char*" or "SV*", depending on the value of
               "HeKLEN()".  Can be assigned to.  The "HePV()" or
               "HeSVKEY()" macros are usually preferable for
               finding the value of a key.

                       void*   HeKEY(HE* he)


       HeKLEN  If this is negative, and amounts to "HEf_SVKEY",
               it indicates the entry holds an "SV*" key.  Other­
               wise, holds the actual length of the key.  Can be
               assigned to. The "HePV()" macro is usually prefer­
               able for finding key lengths.

                       STRLEN  HeKLEN(HE* he)


       HePV    Returns the key slot of the hash entry as a
               "char*" value, doing any necessary dereferencing
               of possibly "SV*" keys.  The length of the string
               is placed in "len" (this is a macro, so do not use
               "&len").  If you do not care about what the length
               of the key is, you may use the global variable
               "PL_na", though this is rather less efficient than
               using a local variable.  Remember though, that
               hash keys in perl are free to contain embedded
               nulls, so using "strlen()" or similar is not a
               good way to find the length of hash keys. This is
               very similar to the "SvPV()" macro described else­
               where in this document.

                       char*   HePV(HE* he, STRLEN len)


       HeSVKEY Returns the key as an "SV*", or "Nullsv" if the
               hash entry does not contain an "SV*" key.

                       SV*     HeSVKEY(HE* he)


       HeSVKEY_force
               Returns the key as an "SV*".  Will create and
               return a temporary mortal "SV*" if the hash entry
               contains only a "char*" key.

                       SV*     HeSVKEY_force(HE* he)


       HeSVKEY_set
               Sets the key to a given "SV*", taking care to set
               the appropriate flags to indicate the presence of
               an "SV*" key, and returns the same "SV*".

                       SV*     HeSVKEY_set(HE* he, SV* sv)


       HeVAL   Returns the value slot (type "SV*") stored in the
               hash entry.

                       SV*     HeVAL(HE* he)


       HvNAME  Returns the package name of a stash.  See "SvS­
               TASH", "CvSTASH".

                       char*   HvNAME(HV* stash)


       hv_clear
               Clears a hash, making it empty.

                       void    hv_clear(HV* tb)


       hv_delete
               Deletes a key/value pair in the hash.  The value
               SV is removed from the hash and returned to the
               caller.  The "klen" is the length of the key.  The
               "flags" value will normally be zero; if set to
               G_DISCARD then NULL will be returned.

                       SV*     hv_delete(HV* tb, const char* key, U32 klen, I32 flags)


       hv_delete_ent
               Deletes a key/value pair in the hash.  The value
               SV is removed from the hash and returned to the
               caller.  The "flags" value will normally be zero;
               if set to G_DISCARD then NULL will be returned.
               "hash" can be a valid precomputed hash value, or 0
               to ask for it to be computed.

                       SV*     hv_delete_ent(HV* tb, SV* key, I32 flags, U32 hash)


       hv_exists
               Returns a boolean indicating whether the specified
               hash key exists.  The "klen" is the length of the
               key.

                       bool    hv_exists(HV* tb, const char* key, U32 klen)


       hv_exists_ent
               Returns a boolean indicating whether the specified
               hash key exists. "hash" can be a valid precomputed
               hash value, or 0 to ask for it to be computed.

                       bool    hv_exists_ent(HV* tb, SV* key, U32 hash)


       hv_fetch
               Returns the SV which corresponds to the specified
               key in the hash.  The "klen" is the length of the
               key.  If "lval" is set then the fetch will be part
               of a store.  Check that the return value is non-
               null before dereferencing it to a "SV*".

               See the Understanding the Magic of Tied Hashes and
               Arrays entry in the perlguts manpage for more
               information on how to use this function on tied
               hashes.

                       SV**    hv_fetch(HV* tb, const char* key, U32 klen, I32 lval)



       hv_fetch_ent
               Returns the hash entry which corresponds to the
               specified key in the hash.  "hash" must be a valid
               precomputed hash number for the given "key", or 0
               if you want the function to compute it.  IF "lval"
               is set then the fetch will be part of a store.
               Make sure the return value is non-null before
               accessing it.  The return value when "tb" is a
               tied hash is a pointer to a static location, so be
               sure to make a copy of the structure if you need
               to store it somewhere.

               See the Understanding the Magic of Tied Hashes and
               Arrays entry in the perlguts manpage for more
               information on how to use this function on tied
               hashes.

                       HE*     hv_fetch_ent(HV* tb, SV* key, I32 lval, U32 hash)


       hv_iterinit
               Prepares a starting point to traverse a hash
               table.  Returns the number of keys in the hash
               (i.e. the same as "HvKEYS(tb)").  The return value
               is currently only meaningful for hashes without
               tie magic.

               NOTE: Before version 5.004_65, "hv_iterinit" used
               to return the number of hash buckets that happen
               to be in use.  If you still need that esoteric
               value, you can get it through the macro
               "HvFILL(tb)".

                       I32     hv_iterinit(HV* tb)


       hv_iterkey
               Returns the key from the current position of the
               hash iterator.  See "hv_iterinit".

                       char*   hv_iterkey(HE* entry, I32* retlen)


       hv_iterkeysv
               Returns the key as an "SV*" from the current posi­
               tion of the hash iterator.  The return value will
               always be a mortal copy of the key.  Also see
               "hv_iterinit".

                       SV*     hv_iterkeysv(HE* entry)


       hv_iternext
               Returns entries from a hash iterator.  See
               "hv_iterinit".

                       HE*     hv_iternext(HV* tb)


       hv_iternextsv
               Performs an "hv_iternext", "hv_iterkey", and
               "hv_iterval" in one operation.

                       SV*     hv_iternextsv(HV* hv, char** key, I32* retlen)


       hv_iterval
               Returns the value from the current position of the
               hash iterator.  See "hv_iterkey".

                       SV*     hv_iterval(HV* tb, HE* entry)


       hv_magic
               Adds magic to a hash.  See "sv_magic".

                       void    hv_magic(HV* hv, GV* gv, int how)


       hv_store
               Stores an SV in a hash.  The hash key is specified
               as "key" and "klen" is the length of the key.  The
               "hash" parameter is the precomputed hash value; if
               it is zero then Perl will compute it.  The return
               value will be NULL if the operation failed or if
               the value did not need to be actually stored
               within the hash (as in the case of tied hashes).
               Otherwise it can be dereferenced to get the origi­
               nal "SV*".  Note that the caller is responsible
               for suitably incrementing the reference count of
               "val" before the call, and decrementing it if the
               function returned NULL.

               See the Understanding the Magic of Tied Hashes and
               Arrays entry in the perlguts manpage for more
               information on how to use this function on tied
               hashes.

                       SV**    hv_store(HV* tb, const char* key, U32 klen, SV* val, U32 hash)


       hv_store_ent
               Stores "val" in a hash.  The hash key is specified
               as "key".  The "hash" parameter is the precomputed
               hash value; if it is zero then Perl will compute
               it.  The return value is the new hash entry so
               created.  It will be NULL if the operation failed
               or if the value did not need to be actually stored
               within the hash (as in the case of tied hashes).
               Otherwise the contents of the return value can be
               accessed using the "He???" macros described here.
               Note that the caller is responsible for suitably
               incrementing the reference count of "val" before
               the call, and decrementing it if the function
               returned NULL.

               See the Understanding the Magic of Tied Hashes and
               Arrays entry in the perlguts manpage for more
               information on how to use this function on tied
               hashes.

                       HE*     hv_store_ent(HV* tb, SV* key, SV* val, U32 hash)


       hv_undef
               Undefines the hash.

                       void    hv_undef(HV* tb)




       isALNUM Returns a boolean indicating whether the C "char"
               is an ASCII alphanumeric character (including
               underscore) or digit.

                       bool    isALNUM(char ch)


       isALPHA Returns a boolean indicating whether the C "char"
               is an ASCII alphabetic character.

                       bool    isALPHA(char ch)


       isDIGIT Returns a boolean indicating whether the C "char"
               is an ASCII digit.

                       bool    isDIGIT(char ch)


       isLOWER Returns a boolean indicating whether the C "char"
               is a lowercase character.

                       bool    isLOWER(char ch)


       isSPACE Returns a boolean indicating whether the C "char"
               is whitespace.

                       bool    isSPACE(char ch)


       isUPPER Returns a boolean indicating whether the C "char"
               is an uppercase character.

                       bool    isUPPER(char ch)


       is_utf8_char
               Tests if some arbitrary number of bytes begins in
               a valid UTF-8 character.  The actual number of
               bytes in the UTF-8 character will be returned if
               it is valid, otherwise 0.

                       STRLEN  is_utf8_char(U8 *p)


       is_utf8_string
               Returns true if first "len" bytes of the given
               string form valid a UTF8 string, false otherwise.

                       bool    is_utf8_string(U8 *s, STRLEN len)


       items   Variable which is setup by "xsubpp" to indicate
               the number of items on the stack.  See the Vari­
               able-length Parameter Lists entry in the perlxs
               manpage.

                       I32     items


       ix      Variable which is setup by "xsubpp" to indicate
               which of an XSUB's aliases was used to invoke it.
               See the The ALIAS: Keyword entry in the perlxs
               manpage.

                       I32     ix


       LEAVE   Closing bracket on a callback.  See "ENTER" and
               the perlcall manpage.

                               LEAVE;


       looks_like_number
               Test if an the content of an SV looks like a num­
               ber (or is a number).

                       I32     looks_like_number(SV* sv)


       MARK    Stack marker variable for the XSUB.  See "dMARK".

       mg_clear
               Clear something magical that the SV represents.
               See "sv_magic".

                       int     mg_clear(SV* sv)


       mg_copy Copies the magic from one SV to another.  See
               "sv_magic".

                       int     mg_copy(SV* sv, SV* nsv, const char* key, I32 klen)


       mg_find Finds the magic pointer for type matching the SV.
               See "sv_magic".

                       MAGIC*  mg_find(SV* sv, int type)


       mg_free Free any magic storage used by the SV.  See
               "sv_magic".

                       int     mg_free(SV* sv)


       mg_get  Do magic after a value is retrieved from the SV.
               See "sv_magic".

                       int     mg_get(SV* sv)


       mg_length
               Report on the SV's length.  See "sv_magic".

                       U32     mg_length(SV* sv)


       mg_magical
               Turns on the magical status of an SV.  See
               "sv_magic".

                       void    mg_magical(SV* sv)


       mg_set  Do magic after a value is assigned to the SV.  See
               "sv_magic".

                       int     mg_set(SV* sv)


       Move    The XSUB-writer's interface to the C "memmove"
               function.  The "src" is the source, "dest" is the
               destination, "nitems" is the number of items, and
               "type" is the type.  Can do overlapping moves.
               See also "Copy".

                       void    Move(void* src, void* dest, int nitems, type)


       New     The XSUB-writer's interface to the C "malloc"
               function.

                       void    New(int id, void* ptr, int nitems, type)


       newAV   Creates a new AV.  The reference count is set to
               1.

                       AV*     newAV()


       Newc    The XSUB-writer's interface to the C "malloc"
               function, with cast.

                       void    Newc(int id, void* ptr, int nitems, type, cast)


       newCONSTSUB
               Creates a constant sub equivalent to Perl "sub FOO
               () { 123 }" which is eligible for inlining at com­
               pile-time.

                       void    newCONSTSUB(HV* stash, char* name, SV* sv)


       newHV   Creates a new HV.  The reference count is set to
               1.

                       HV*     newHV()


       newRV_inc
               Creates an RV wrapper for an SV.  The reference
               count for the original SV is incremented.

                       SV*     newRV_inc(SV* sv)


       newRV_noinc
               Creates an RV wrapper for an SV.  The reference
               count for the original SV is nnoott incremented.

                       SV*     newRV_noinc(SV *sv)


       NEWSV   Creates a new SV.  A non-zero "len" parameter
               indicates the number of bytes of preallocated
               string space the SV should have.  An extra byte
               for a tailing NUL is also reserved.  (SvPOK is not
               set for the SV even if string space is allocated.)
               The reference count for the new SV is set to 1.
               "id" is an integer id between 0 and 1299 (used to
               identify leaks).

                       SV*     NEWSV(int id, STRLEN len)


       newSViv Creates a new SV and copies an integer into it.
               The reference count for the SV is set to 1.

                       SV*     newSViv(IV i)


       newSVnv Creates a new SV and copies a floating point value
               into it.  The reference count for the SV is set to
               1.

                       SV*     newSVnv(NV n)


       newSVpv Creates a new SV and copies a string into it.  The
               reference count for the SV is set to 1.  If "len"
               is zero, Perl will compute the length using
               strlen().  For efficiency, consider using
               "newSVpvn" instead.

                       SV*     newSVpv(const char* s, STRLEN len)


       newSVpvf
               Creates a new SV an initialize it with the string
               formatted like "sprintf".

                       SV*     newSVpvf(const char* pat, ...)


       newSVpvn
               Creates a new SV and copies a string into it.  The
               reference count for the SV is set to 1.  Note that
               if "len" is zero, Perl will create a zero length
               string.  You are responsible for ensuring that the
               source string is at least "len" bytes long.

                       SV*     newSVpvn(const char* s, STRLEN len)


       newSVrv Creates a new SV for the RV, "rv", to point to.
               If "rv" is not an RV then it will be upgraded to
               one.  If "classname" is non-null then the new SV
               will be blessed in the specified package.  The new
               SV is returned and its reference count is 1.

                       SV*     newSVrv(SV* rv, const char* classname)


       newSVsv Creates a new SV which is an exact duplicate of
               the original SV.

                       SV*     newSVsv(SV* old)


       newSVuv Creates a new SV and copies an unsigned integer
               into it.  The reference count for the SV is set to
               1.

                       SV*     newSVuv(UV u)




       newXS   Used by "xsubpp" to hook up XSUBs as Perl subs.

       newXSproto
               Used by "xsubpp" to hook up XSUBs as Perl subs.
               Adds Perl prototypes to the subs.

       Newz    The XSUB-writer's interface to the C "malloc"
               function.  The allocated memory is zeroed with
               "memzero".

                       void    Newz(int id, void* ptr, int nitems, type)


       Nullav  Null AV pointer.

       Nullch  Null character pointer.

       Nullcv  Null CV pointer.

       Nullhv  Null HV pointer.

       Nullsv  Null SV pointer.

       ORIGMARK
               The original stack mark for the XSUB.  See "dORIG­
               MARK".

       perl_alloc
               Allocates a new Perl interpreter.  See the perlem­
               bed manpage.

                       PerlInterpreter*        perl_alloc()


       perl_construct
               Initializes a new Perl interpreter.  See the per­
               lembed manpage.

                       void    perl_construct(PerlInterpreter* interp)


       perl_destruct
               Shuts down a Perl interpreter.  See the perlembed
               manpage.

                       void    perl_destruct(PerlInterpreter* interp)


       perl_free
               Releases a Perl interpreter.  See the perlembed
               manpage.

                       void    perl_free(PerlInterpreter* interp)


       perl_parse
               Tells a Perl interpreter to parse a Perl script.
               See the perlembed manpage.

                       int     perl_parse(PerlInterpreter* interp, XSINIT_t xsinit, int argc, char** argv, char** env)


       perl_run
               Tells a Perl interpreter to run.  See the perlem­
               bed manpage.

                       int     perl_run(PerlInterpreter* interp)


       PL_modglobal
               "PL_modglobal" is a general purpose, interpreter
               global HV for use by extensions that need to keep
               information on a per-interpreter basis.  In a
               pinch, it can also be used as a symbol table for
               extensions to share data among each other.  It is
               a good idea to use keys prefixed by the package
               name of the extension that owns the data.

                       HV*     PL_modglobal


       PL_na   A convenience variable which is typically used
               with "SvPV" when one doesn't care about the length
               of the string.  It is usually more efficient to
               either declare a local variable and use that
               instead or to use the "SvPV_nolen" macro.

                       STRLEN  PL_na


       PL_sv_no
               This is the "false" SV.  See "PL_sv_yes".  Always
               refer to this as "&PL_sv_no".

                       SV      PL_sv_no


       PL_sv_undef
               This is the "undef" SV.  Always refer to this as
               "&PL_sv_undef".

                       SV      PL_sv_undef


       PL_sv_yes
               This is the "true" SV.  See "PL_sv_no".  Always
               refer to this as "&PL_sv_yes".

                       SV      PL_sv_yes


       POPi    Pops an integer off the stack.

                       IV      POPi


       POPl    Pops a long off the stack.

                       long    POPl


       POPn    Pops a double off the stack.

                       NV      POPn


       POPp    Pops a string off the stack.

                       char*   POPp



       POPs    Pops an SV off the stack.

                       SV*     POPs


       PUSHi   Push an integer onto the stack.  The stack must
               have room for this element.  Handles 'set' magic.
               See "XPUSHi".

                       void    PUSHi(IV iv)


       PUSHMARK
               Opening bracket for arguments on a callback.  See
               "PUTBACK" and the perlcall manpage.

                               PUSHMARK;


       PUSHn   Push a double onto the stack.  The stack must have
               room for this element.  Handles 'set' magic.  See
               "XPUSHn".

                       void    PUSHn(NV nv)


       PUSHp   Push a string onto the stack.  The stack must have
               room for this element.  The "len" indicates the
               length of the string.  Handles 'set' magic.  See
               "XPUSHp".

                       void    PUSHp(char* str, STRLEN len)


       PUSHs   Push an SV onto the stack.  The stack must have
               room for this element.  Does not handle 'set'
               magic.  See "XPUSHs".

                       void    PUSHs(SV* sv)


       PUSHu   Push an unsigned integer onto the stack.  The
               stack must have room for this element.  See
               "XPUSHu".

                       void    PUSHu(UV uv)


       PUTBACK Closing bracket for XSUB arguments.  This is usu­
               ally handled by "xsubpp".  See "PUSHMARK" and the
               perlcall manpage for other uses.

                               PUTBACK;


       Renew   The XSUB-writer's interface to the C "realloc"
               function.

                       void    Renew(void* ptr, int nitems, type)


       Renewc  The XSUB-writer's interface to the C "realloc"
               function, with cast.

                       void    Renewc(void* ptr, int nitems, type, cast)


       require_pv
               Tells Perl to "require" a module.

               NOTE: the perl_ form of this function is depre­
               cated.

                       void    require_pv(const char* pv)


       RETVAL  Variable which is setup by "xsubpp" to hold the
               return value for an XSUB. This is always the
               proper type for the XSUB. See the The RETVAL Vari­
               able entry in the perlxs manpage.

                       (whatever)      RETVAL


       Safefree
               The XSUB-writer's interface to the C "free" func­
               tion.

                       void    Safefree(void* ptr)


       savepv  Copy a string to a safe spot.  This does not use
               an SV.

                       char*   savepv(const char* sv)


       savepvn Copy a string to a safe spot.  The "len" indicates
               number of bytes to copy.  This does not use an SV.

                       char*   savepvn(const char* sv, I32 len)


       SAVETMPS
               Opening bracket for temporaries on a callback.
               See "FREETMPS" and the perlcall manpage.

                               SAVETMPS;


       SP      Stack pointer.  This is usually handled by
               "xsubpp".  See "dSP" and "SPAGAIN".

       SPAGAIN Refetch the stack pointer.  Used after a callback.
               See the perlcall manpage.

                               SPAGAIN;


       ST      Used to access elements on the XSUB's stack.

                       SV*     ST(int ix)


       strEQ   Test two strings to see if they are equal.
               Returns true or false.

                       bool    strEQ(char* s1, char* s2)




       strGE   Test two strings to see if the first, "s1", is
               greater than or equal to the second, "s2".
               Returns true or false.

                       bool    strGE(char* s1, char* s2)


       strGT   Test two strings to see if the first, "s1", is
               greater than the second, "s2".  Returns true or
               false.

                       bool    strGT(char* s1, char* s2)


       strLE   Test two strings to see if the first, "s1", is
               less than or equal to the second, "s2".  Returns
               true or false.

                       bool    strLE(char* s1, char* s2)


       strLT   Test two strings to see if the first, "s1", is
               less than the second, "s2".  Returns true or
               false.

                       bool    strLT(char* s1, char* s2)


       strNE   Test two strings to see if they are different.
               Returns true or false.

                       bool    strNE(char* s1, char* s2)


       strnEQ  Test two strings to see if they are equal.  The
               "len" parameter indicates the number of bytes to
               compare.  Returns true or false. (A wrapper for
               "strncmp").

                       bool    strnEQ(char* s1, char* s2, STRLEN len)


       strnNE  Test two strings to see if they are different.
               The "len" parameter indicates the number of bytes
               to compare.  Returns true or false. (A wrapper for
               "strncmp").

                       bool    strnNE(char* s1, char* s2, STRLEN len)


       StructCopy
               This is an architecture-independent macro to copy
               one structure to another.

                       void    StructCopy(type src, type dest, type)


       SvCUR   Returns the length of the string which is in the
               SV.  See "SvLEN".

                       STRLEN  SvCUR(SV* sv)


       SvCUR_set
               Set the length of the string which is in the SV.
               See "SvCUR".

                       void    SvCUR_set(SV* sv, STRLEN len)


       SvEND   Returns a pointer to the last character in the
               string which is in the SV.  See "SvCUR".  Access
               the character as *(SvEND(sv)).

                       char*   SvEND(SV* sv)


       SvGETMAGIC
               Invokes "mg_get" on an SV if it has 'get' magic.
               This macro evaluates its argument more than once.

                       void    SvGETMAGIC(SV* sv)


       SvGROW  Expands the character buffer in the SV so that it
               has room for the indicated number of bytes (remem­
               ber to reserve space for an extra trailing NUL
               character).  Calls "sv_grow" to perform the expan­
               sion if necessary.  Returns a pointer to the char­
               acter buffer.

                       void    SvGROW(SV* sv, STRLEN len)


       SvIOK   Returns a boolean indicating whether the SV con­
               tains an integer.

                       bool    SvIOK(SV* sv)


       SvIOKp  Returns a boolean indicating whether the SV con­
               tains an integer.  Checks the pprriivvaattee setting.
               Use "SvIOK".

                       bool    SvIOKp(SV* sv)


       SvIOK_notUV
               Returns a boolean indicating whether the SV con­
               tains an signed integer.

                       void    SvIOK_notUV(SV* sv)


       SvIOK_off
               Unsets the IV status of an SV.

                       void    SvIOK_off(SV* sv)


       SvIOK_on
               Tells an SV that it is an integer.

                       void    SvIOK_on(SV* sv)


       SvIOK_only
               Tells an SV that it is an integer and disables all
               other OK bits.

                       void    SvIOK_only(SV* sv)


       SvIOK_only_UV
               Tells and SV that it is an unsigned integer and
               disables all other OK bits.

                       void    SvIOK_only_UV(SV* sv)


       SvIOK_UV
               Returns a boolean indicating whether the SV con­
               tains an unsigned integer.

                       void    SvIOK_UV(SV* sv)


       SvIV    Coerces the given SV to an integer and returns it.

                       IV      SvIV(SV* sv)


       SvIVX   Returns the integer which is stored in the SV,
               assuming SvIOK is true.

                       IV      SvIVX(SV* sv)


       SvLEN   Returns the size of the string buffer in the SV,
               not including any part attributable to "SvOOK".
               See "SvCUR".

                       STRLEN  SvLEN(SV* sv)


       SvNIOK  Returns a boolean indicating whether the SV con­
               tains a number, integer or double.

                       bool    SvNIOK(SV* sv)


       SvNIOKp Returns a boolean indicating whether the SV con­
               tains a number, integer or double.  Checks the
               pprriivvaattee setting.  Use "SvNIOK".

                       bool    SvNIOKp(SV* sv)


       SvNIOK_off
               Unsets the NV/IV status of an SV.

                       void    SvNIOK_off(SV* sv)


       SvNOK   Returns a boolean indicating whether the SV con­
               tains a double.

                       bool    SvNOK(SV* sv)


       SvNOKp  Returns a boolean indicating whether the SV con­
               tains a double.  Checks the pprriivvaattee setting.  Use
               "SvNOK".

                       bool    SvNOKp(SV* sv)



       SvNOK_off
               Unsets the NV status of an SV.

                       void    SvNOK_off(SV* sv)


       SvNOK_on
               Tells an SV that it is a double.

                       void    SvNOK_on(SV* sv)


       SvNOK_only
               Tells an SV that it is a double and disables all
               other OK bits.

                       void    SvNOK_only(SV* sv)


       SvNV    Coerce the given SV to a double and return it.

                       NV      SvNV(SV* sv)


       SvNVX   Returns the double which is stored in the SV,
               assuming SvNOK is true.

                       NV      SvNVX(SV* sv)


       SvOK    Returns a boolean indicating whether the value is
               an SV.

                       bool    SvOK(SV* sv)


       SvOOK   Returns a boolean indicating whether the SvIVX is
               a valid offset value for the SvPVX.  This hack is
               used internally to speed up removal of characters
               from the beginning of a SvPV.  When SvOOK is true,
               then the start of the allocated string buffer is
               really (SvPVX - SvIVX).

                       bool    SvOOK(SV* sv)


       SvPOK   Returns a boolean indicating whether the SV con­
               tains a character string.

                       bool    SvPOK(SV* sv)


       SvPOKp  Returns a boolean indicating whether the SV con­
               tains a character string.  Checks the pprriivvaattee set­
               ting.  Use "SvPOK".

                       bool    SvPOKp(SV* sv)


       SvPOK_off
               Unsets the PV status of an SV.

                       void    SvPOK_off(SV* sv)



       SvPOK_on
               Tells an SV that it is a string.

                       void    SvPOK_on(SV* sv)


       SvPOK_only
               Tells an SV that it is a string and disables all
               other OK bits.

                       void    SvPOK_only(SV* sv)


       SvPOK_only_UTF8
               Tells an SV that it is a UTF8 string (do not use
               frivolously) and disables all other OK bits.

                       void    SvPOK_only_UTF8(SV* sv)


       SvPV    Returns a pointer to the string in the SV, or a
               stringified form of the SV if the SV does not con­
               tain a string.  Handles 'get' magic.

                       char*   SvPV(SV* sv, STRLEN len)


       SvPVX   Returns a pointer to the string in the SV.  The SV
               must contain a string.

                       char*   SvPVX(SV* sv)


       SvPV_force
               Like <SvPV> but will force the SV into becoming a
               string (SvPOK).  You want force if you are going
               to update the SvPVX directly.

                       char*   SvPV_force(SV* sv, STRLEN len)


       SvPV_nolen
               Returns a pointer to the string in the SV, or a
               stringified form of the SV if the SV does not con­
               tain a string.  Handles 'get' magic.

                       char*   SvPV_nolen(SV* sv)


       SvREFCNT
               Returns the value of the object's reference count.

                       U32     SvREFCNT(SV* sv)


       SvREFCNT_dec
               Decrements the reference count of the given SV.

                       void    SvREFCNT_dec(SV* sv)


       SvREFCNT_inc
               Increments the reference count of the given SV.

                       SV*     SvREFCNT_inc(SV* sv)


       SvROK   Tests if the SV is an RV.

                       bool    SvROK(SV* sv)


       SvROK_off
               Unsets the RV status of an SV.

                       void    SvROK_off(SV* sv)


       SvROK_on
               Tells an SV that it is an RV.

                       void    SvROK_on(SV* sv)


       SvRV    Dereferences an RV to return the SV.

                       SV*     SvRV(SV* sv)


       SvSETMAGIC
               Invokes "mg_set" on an SV if it has 'set' magic.
               This macro evaluates its argument more than once.

                       void    SvSETMAGIC(SV* sv)


       SvSetSV Calls "sv_setsv" if dsv is not the same as ssv.
               May evaluate arguments more than once.

                       void    SvSetSV(SV* dsb, SV* ssv)


       SvSetSV_nosteal
               Calls a non-destructive version of "sv_setsv" if
               dsv is not the same as ssv. May evaluate arguments
               more than once.

                       void    SvSetSV_nosteal(SV* dsv, SV* ssv)


       SvSTASH Returns the stash of the SV.

                       HV*     SvSTASH(SV* sv)


       SvTAINT Taints an SV if tainting is enabled

                       void    SvTAINT(SV* sv)


       SvTAINTED
               Checks to see if an SV is tainted. Returns TRUE if
               it is, FALSE if not.

                       bool    SvTAINTED(SV* sv)


       SvTAINTED_off
               Untaints an SV. Be very careful with this routine,
               as it short-circuits some of Perl's fundamental
               security features. XS module authors should not
               use this function unless they fully understand all
               the implications of unconditionally untainting the
               value. Untainting should be done in the standard
               perl fashion, via a carefully crafted regexp,
               rather than directly untainting variables.

                       void    SvTAINTED_off(SV* sv)


       SvTAINTED_on
               Marks an SV as tainted.

                       void    SvTAINTED_on(SV* sv)


       SvTRUE  Returns a boolean indicating whether Perl would
               evaluate the SV as true or false, defined or unde­
               fined.  Does not handle 'get' magic.

                       bool    SvTRUE(SV* sv)


       svtype  An enum of flags for Perl types.  These are found
               in the file ssvv..hh in the "svtype" enum.  Test these
               flags with the "SvTYPE" macro.

       SvTYPE  Returns the type of the SV.  See "svtype".

                       svtype  SvTYPE(SV* sv)


       SVt_IV  Integer type flag for scalars.  See "svtype".

       SVt_NV  Double type flag for scalars.  See "svtype".

       SVt_PV  Pointer type flag for scalars.  See "svtype".

       SVt_PVAV
               Type flag for arrays.  See "svtype".

       SVt_PVCV
               Type flag for code refs.  See "svtype".

       SVt_PVHV
               Type flag for hashes.  See "svtype".

       SVt_PVMG
               Type flag for blessed scalars.  See "svtype".

       SvUPGRADE
               Used to upgrade an SV to a more complex form.
               Uses "sv_upgrade" to perform the upgrade if neces­
               sary.  See "svtype".

                       void    SvUPGRADE(SV* sv, svtype type)


       SvUTF8  Returns a boolean indicating whether the SV con­
               tains UTF-8 encoded data.

                       void    SvUTF8(SV* sv)


       SvUTF8_off
               Unsets the UTF8 status of an SV.

                       void    SvUTF8_off(SV *sv)


       SvUTF8_on
               Tells an SV that it is a string and encoded in
               UTF8.  Do not use frivolously.

                       void    SvUTF8_on(SV *sv)


       SvUV    Coerces the given SV to an unsigned integer and
               returns it.

                       UV      SvUV(SV* sv)


       SvUVX   Returns the unsigned integer which is stored in
               the SV, assuming SvIOK is true.

                       UV      SvUVX(SV* sv)


       sv_2mortal
               Marks an SV as mortal.  The SV will be destroyed
               when the current context ends.

                       SV*     sv_2mortal(SV* sv)


       sv_bless
               Blesses an SV into a specified package.  The SV
               must be an RV.  The package must be designated by
               its stash (see "gv_stashpv()").  The reference
               count of the SV is unaffected.

                       SV*     sv_bless(SV* sv, HV* stash)


       sv_catpv
               Concatenates the string onto the end of the string
               which is in the SV.  Handles 'get' magic, but not
               'set' magic.  See "sv_catpv_mg".

                       void    sv_catpv(SV* sv, const char* ptr)


       sv_catpvf
               Processes its arguments like "sprintf" and appends
               the formatted output to an SV.  Handles 'get'
               magic, but not 'set' magic.  "SvSETMAGIC()" must
               typically be called after calling this function to
               handle 'set' magic.

                       void    sv_catpvf(SV* sv, const char* pat, ...)


       sv_catpvf_mg
               Like "sv_catpvf", but also handles 'set' magic.

                       void    sv_catpvf_mg(SV *sv, const char* pat, ...)


       sv_catpvn
               Concatenates the string onto the end of the string
               which is in the SV.  The "len" indicates number of
               bytes to copy.  Handles 'get' magic, but not 'set'
               magic.  See "sv_catpvn_mg".

                       void    sv_catpvn(SV* sv, const char* ptr, STRLEN len)


       sv_catpvn_mg
               Like "sv_catpvn", but also handles 'set' magic.

                       void    sv_catpvn_mg(SV *sv, const char *ptr, STRLEN len)


       sv_catpv_mg
               Like "sv_catpv", but also handles 'set' magic.

                       void    sv_catpv_mg(SV *sv, const char *ptr)


       sv_catsv
               Concatenates the string from SV "ssv" onto the end
               of the string in SV "dsv".  Modifies "dsv" but not
               "ssv".  Handles 'get' magic, but not 'set' magic.
               See "sv_catsv_mg".

                       void    sv_catsv(SV* dsv, SV* ssv)


       sv_catsv_mg
               Like "sv_catsv", but also handles 'set' magic.

                       void    sv_catsv_mg(SV *dstr, SV *sstr)


       sv_chop Efficient removal of characters from the beginning
               of the string buffer.  SvPOK(sv) must be true and
               the "ptr" must be a pointer to somewhere inside
               the string buffer.  The "ptr" becomes the first
               character of the adjusted string.

                       void    sv_chop(SV* sv, char* ptr)


       sv_clear
               Clear an SV, making it empty. Does not free the
               memory used by the SV itself.

                       void    sv_clear(SV* sv)


       sv_cmp  Compares the strings in two SVs.  Returns -1, 0,
               or 1 indicating whether the string in "sv1" is
               less than, equal to, or greater than the string in
               "sv2".

                       I32     sv_cmp(SV* sv1, SV* sv2)


       sv_cmp_locale
               Compares the strings in two SVs in a locale-aware
               manner. See the sv_cmp_locale entry elsewhere in
               this document

                       I32     sv_cmp_locale(SV* sv1, SV* sv2)


       sv_dec  Auto-decrement of the value in the SV.

                       void    sv_dec(SV* sv)


       sv_derived_from
               Returns a boolean indicating whether the SV is
               derived from the specified class.  This is the
               function that implements "UNIVERSAL::isa".  It
               works for class names as well as for objects.

                       bool    sv_derived_from(SV* sv, const char* name)


       sv_eq   Returns a boolean indicating whether the strings
               in the two SVs are identical.

                       I32     sv_eq(SV* sv1, SV* sv2)


       sv_free Free the memory used by an SV.

                       void    sv_free(SV* sv)


       sv_gets Get a line from the filehandle and store it into
               the SV, optionally appending to the currently-
               stored string.

                       char*   sv_gets(SV* sv, PerlIO* fp, I32 append)


       sv_grow Expands the character buffer in the SV.  This will
               use "sv_unref" and will upgrade the SV to
               "SVt_PV".  Returns a pointer to the character
               buffer.  Use "SvGROW".

                       char*   sv_grow(SV* sv, STRLEN newlen)


       sv_inc  Auto-increment of the value in the SV.

                       void    sv_inc(SV* sv)


       sv_insert
               Inserts a string at the specified offset/length
               within the SV. Similar to the Perl substr() func­
               tion.

                       void    sv_insert(SV* bigsv, STRLEN offset, STRLEN len, char* little, STRLEN littlelen)


       sv_isa  Returns a boolean indicating whether the SV is
               blessed into the specified class.  This does not
               check for subtypes; use "sv_derived_from" to ver­
               ify an inheritance relationship.

                       int     sv_isa(SV* sv, const char* name)


       sv_isobject
               Returns a boolean indicating whether the SV is an
               RV pointing to a blessed object.  If the SV is not
               an RV, or if the object is not blessed, then this
               will return false.

                       int     sv_isobject(SV* sv)


       sv_len  Returns the length of the string in the SV.  See
               also "SvCUR".

                       STRLEN  sv_len(SV* sv)


       sv_len_utf8
               Returns the number of characters in the string in
               an SV, counting wide UTF8 bytes as a single char­
               acter.

                       STRLEN  sv_len_utf8(SV* sv)


       sv_magic
               Adds magic to an SV.

                       void    sv_magic(SV* sv, SV* obj, int how, const char* name, I32 namlen)


       sv_mortalcopy
               Creates a new SV which is a copy of the original
               SV.  The new SV is marked as mortal.

                       SV*     sv_mortalcopy(SV* oldsv)


       sv_newmortal
               Creates a new SV which is mortal.  The reference
               count of the SV is set to 1.

                       SV*     sv_newmortal()


       sv_pvn_force
               Get a sensible string out of the SV somehow.

                       char*   sv_pvn_force(SV* sv, STRLEN* lp)


       sv_pvutf8n_force
               Get a sensible UTF8-encoded string out of the SV
               somehow. See the sv_pvn_force entry elsewhere in
               this document.

                       char*   sv_pvutf8n_force(SV* sv, STRLEN* lp)


       sv_reftype
               Returns a string describing what the SV is a ref­
               erence to.

                       char*   sv_reftype(SV* sv, int ob)


       sv_replace
               Make the first argument a copy of the second, then
               delete the original.

                       void    sv_replace(SV* sv, SV* nsv)


       sv_rvweaken
               Weaken a reference.

                       SV*     sv_rvweaken(SV *sv)


       sv_setiv
               Copies an integer into the given SV.  Does not
               handle 'set' magic.  See "sv_setiv_mg".

                       void    sv_setiv(SV* sv, IV num)


       sv_setiv_mg
               Like "sv_setiv", but also handles 'set' magic.

                       void    sv_setiv_mg(SV *sv, IV i)


       sv_setnv
               Copies a double into the given SV.  Does not han­
               dle 'set' magic.  See "sv_setnv_mg".

                       void    sv_setnv(SV* sv, NV num)


       sv_setnv_mg
               Like "sv_setnv", but also handles 'set' magic.

                       void    sv_setnv_mg(SV *sv, NV num)


       sv_setpv
               Copies a string into an SV.  The string must be
               null-terminated.  Does not handle 'set' magic.
               See "sv_setpv_mg".

                       void    sv_setpv(SV* sv, const char* ptr)


       sv_setpvf
               Processes its arguments like "sprintf" and sets an
               SV to the formatted output.  Does not handle 'set'
               magic.  See "sv_setpvf_mg".

                       void    sv_setpvf(SV* sv, const char* pat, ...)


       sv_setpvf_mg
               Like "sv_setpvf", but also handles 'set' magic.

                       void    sv_setpvf_mg(SV *sv, const char* pat, ...)


       sv_setpviv
               Copies an integer into the given SV, also updating
               its string value.  Does not handle 'set' magic.
               See "sv_setpviv_mg".

                       void    sv_setpviv(SV* sv, IV num)


       sv_setpviv_mg
               Like "sv_setpviv", but also handles 'set' magic.

                       void    sv_setpviv_mg(SV *sv, IV iv)



       sv_setpvn
               Copies a string into an SV.  The "len" parameter
               indicates the number of bytes to be copied.  Does
               not handle 'set' magic.  See "sv_setpvn_mg".

                       void    sv_setpvn(SV* sv, const char* ptr, STRLEN len)


       sv_setpvn_mg
               Like "sv_setpvn", but also handles 'set' magic.

                       void    sv_setpvn_mg(SV *sv, const char *ptr, STRLEN len)


       sv_setpv_mg
               Like "sv_setpv", but also handles 'set' magic.

                       void    sv_setpv_mg(SV *sv, const char *ptr)


       sv_setref_iv
               Copies an integer into a new SV, optionally bless­
               ing the SV.  The "rv" argument will be upgraded to
               an RV.  That RV will be modified to point to the
               new SV.  The "classname" argument indicates the
               package for the blessing.  Set "classname" to
               "Nullch" to avoid the blessing.  The new SV will
               be returned and will have a reference count of 1.

                       SV*     sv_setref_iv(SV* rv, const char* classname, IV iv)


       sv_setref_nv
               Copies a double into a new SV, optionally blessing
               the SV.  The "rv" argument will be upgraded to an
               RV.  That RV will be modified to point to the new
               SV.  The "classname" argument indicates the pack­
               age for the blessing.  Set "classname" to "Nullch"
               to avoid the blessing.  The new SV will be
               returned and will have a reference count of 1.

                       SV*     sv_setref_nv(SV* rv, const char* classname, NV nv)


       sv_setref_pv
               Copies a pointer into a new SV, optionally bless­
               ing the SV.  The "rv" argument will be upgraded to
               an RV.  That RV will be modified to point to the
               new SV.  If the "pv" argument is NULL then
               "PL_sv_undef" will be placed into the SV.  The
               "classname" argument indicates the package for the
               blessing.  Set "classname" to "Nullch" to avoid
               the blessing.  The new SV will be returned and
               will have a reference count of 1.

               Do not use with other Perl types such as HV, AV,
               SV, CV, because those objects will become cor­
               rupted by the pointer copy process.

               Note that "sv_setref_pvn" copies the string while
               this copies the pointer.

                       SV*     sv_setref_pv(SV* rv, const char* classname, void* pv)



       sv_setref_pvn
               Copies a string into a new SV, optionally blessing
               the SV.  The length of the string must be speci­
               fied with "n".  The "rv" argument will be upgraded
               to an RV.  That RV will be modified to point to
               the new SV.  The "classname" argument indicates
               the package for the blessing.  Set "classname" to
               "Nullch" to avoid the blessing.  The new SV will
               be returned and will have a reference count of 1.

               Note that "sv_setref_pv" copies the pointer while
               this copies the string.

                       SV*     sv_setref_pvn(SV* rv, const char* classname, char* pv, STRLEN n)


       sv_setsv
               Copies the contents of the source SV "ssv" into
               the destination SV "dsv".  The source SV may be
               destroyed if it is mortal.  Does not handle 'set'
               magic.  See the macro forms "SvSetSV",
               "SvSetSV_nosteal" and "sv_setsv_mg".

                       void    sv_setsv(SV* dsv, SV* ssv)


       sv_setsv_mg
               Like "sv_setsv", but also handles 'set' magic.

                       void    sv_setsv_mg(SV *dstr, SV *sstr)


       sv_setuv
               Copies an unsigned integer into the given SV.
               Does not handle 'set' magic.  See "sv_setuv_mg".

                       void    sv_setuv(SV* sv, UV num)


       sv_setuv_mg
               Like "sv_setuv", but also handles 'set' magic.

                       void    sv_setuv_mg(SV *sv, UV u)


       sv_true Returns true if the SV has a true value by Perl's
               rules.

                       I32     sv_true(SV *sv)


       sv_unmagic
               Removes magic from an SV.

                       int     sv_unmagic(SV* sv, int type)


       sv_unref
               Unsets the RV status of the SV, and decrements the
               reference count of whatever was being referenced
               by the RV.  This can almost be thought of as a
               reversal of "newSVrv".  See "SvROK_off".

                       void    sv_unref(SV* sv)


       sv_upgrade
               Upgrade an SV to a more complex form.  Use "SvUP­
               GRADE".  See "svtype".

                       bool    sv_upgrade(SV* sv, U32 mt)


       sv_usepvn
               Tells an SV to use "ptr" to find its string value.
               Normally the string is stored inside the SV but
               sv_usepvn allows the SV to use an outside string.
               The "ptr" should point to memory that was allo­
               cated by "malloc".  The string length, "len", must
               be supplied.  This function will realloc the mem­
               ory pointed to by "ptr", so that pointer should
               not be freed or used by the programmer after giv­
               ing it to sv_usepvn.  Does not handle 'set' magic.
               See "sv_usepvn_mg".

                       void    sv_usepvn(SV* sv, char* ptr, STRLEN len)


       sv_usepvn_mg
               Like "sv_usepvn", but also handles 'set' magic.

                       void    sv_usepvn_mg(SV *sv, char *ptr, STRLEN len)


       sv_utf8_downgrade
               Attempt to convert the PV of an SV from
               UTF8-encoded to byte encoding.  This may not be
               possible if the PV contains non-byte encoding
               characters; if this is the case, either returns
               false or, if "fail_ok" is not true, croaks.

               NOTE: this function is experimental and may change
               or be removed without notice.

                       bool    sv_utf8_downgrade(SV *sv, bool fail_ok)


       sv_utf8_encode
               Convert the PV of an SV to UTF8-encoded, but then
               turn off the "SvUTF8" flag so that it looks like
               bytes again. Nothing calls this.

               NOTE: this function is experimental and may change
               or be removed without notice.

                       void    sv_utf8_encode(SV *sv)


       sv_utf8_upgrade
               Convert the PV of an SV to its UTF8-encoded form.

               NOTE: this function is experimental and may change
               or be removed without notice.

                       void    sv_utf8_upgrade(SV *sv)


       sv_vcatpvfn
               Processes its arguments like "vsprintf" and
               appends the formatted output to an SV.  Uses an
               array of SVs if the C style variable argument list
               is missing (NULL).  When running with taint checks
               enabled, indicates via "maybe_tainted" if results
               are untrustworthy (often due to the use of
               locales).

                       void    sv_vcatpvfn(SV* sv, const char* pat, STRLEN patlen, va_list* args, SV** svargs, I32 svmax, bool *maybe_tainted)


       sv_vsetpvfn
               Works like "vcatpvfn" but copies the text into the
               SV instead of appending it.

                       void    sv_vsetpvfn(SV* sv, const char* pat, STRLEN patlen, va_list* args, SV** svargs, I32 svmax, bool *maybe_tainted)


       THIS    Variable which is setup by "xsubpp" to designate
               the object in a C++ XSUB.  This is always the
               proper type for the C++ object.  See "CLASS" and
               the Using XS With C++ entry in the perlxs manpage.

                       (whatever)      THIS


       toLOWER Converts the specified character to lowercase.

                       char    toLOWER(char ch)


       toUPPER Converts the specified character to uppercase.

                       char    toUPPER(char ch)


       utf8_distance
               Returns the number of UTF8 characters between the
               UTF-8 pointers "a" and "b".

               WARNING: use only if you *know* that the pointers
               point inside the same UTF-8 buffer.

               NOTE: this function is experimental and may change
               or be removed without notice.

                       IV      utf8_distance(U8 *a, U8 *b)


       utf8_hop
               Return the UTF-8 pointer "s" displaced by "off"
               characters, either forward or backward.

               WARNING: do not use the following unless you
               *know* "off" is within the UTF-8 data pointed to
               by "s" *and* that on entry "s" is aligned on the
               first byte of character or just after the last
               byte of a character.

               NOTE: this function is experimental and may change
               or be removed without notice.

                       U8*     utf8_hop(U8 *s, I32 off)


       utf8_length
               Return the length of the UTF-8 char encoded string
               "s" in characters.  Stops at "e" (inclusive).  If
               "e < s" or if the scan would end up past "e",
               croaks.

               NOTE: this function is experimental and may change
               or be removed without notice.

                       STRLEN  utf8_length(U8* s, U8 *e)


       utf8_to_bytes
               Converts a string "s" of length "len" from UTF8
               into byte encoding.  Unlike "bytes_to_utf8", this
               over-writes the original string, and updates len
               to contain the new length.  Returns zero on fail­
               ure, setting "len" to -1.

               NOTE: this function is experimental and may change
               or be removed without notice.

                       U8*     utf8_to_bytes(U8 *s, STRLEN *len)


       utf8_to_uv
               Returns the character value of the first character
               in the string "s" which is assumed to be in UTF8
               encoding and no longer than "curlen"; "retlen"
               will be set to the length, in bytes, of that char­
               acter.

               If "s" does not point to a well-formed UTF8 char­
               acter, the behaviour is dependent on the value of
               "flags": if it contains UTF8_CHECK_ONLY, it is
               assumed that the caller will raise a warning, and
               this function will silently just set "retlen" to
               "-1" and return zero.  If the "flags" does not
               contain UTF8_CHECK_ONLY, warnings about malforma­
               tions will be given, "retlen" will be set to the
               expected length of the UTF-8 character in bytes,
               and zero will be returned.

               The "flags" can also contain various flags to
               allow deviations from the strict UTF-8 encoding
               (see utf8.h).

               NOTE: this function is experimental and may change
               or be removed without notice.

                       UV      utf8_to_uv(U8 *s, STRLEN curlen, STRLEN* retlen, U32 flags)


       utf8_to_uv_simple
               Returns the character value of the first character
               in the string "s" which is assumed to be in UTF8
               encoding; "retlen" will be set to the length, in
               bytes, of that character.

               If "s" does not point to a well-formed UTF8 char­
               acter, zero is returned and retlen is set, if pos­
               sible, to -1.

               NOTE: this function is experimental and may change
               or be removed without notice.

                       UV      utf8_to_uv_simple(U8 *s, STRLEN* retlen)




       uv_to_utf8
               Adds the UTF8 representation of the Unicode code­
               point "uv" to the end of the string "d"; "d"
               should be have at least "UTF8_MAXLEN+1" free bytes
               available. The return value is the pointer to the
               byte after the end of the new character. In other
               words,

                   d = uv_to_utf8(d, uv);

               is the recommended Unicode-aware way of saying

                   *(d++) = uv;

               NOTE: this function is experimental and may change
               or be removed without notice.

                       U8*     uv_to_utf8(U8 *d, UV uv)


       warn    This is the XSUB-writer's interface to Perl's
               "warn" function.  Use this function the same way
               you use the C "printf" function.  See "croak".

                       void    warn(const char* pat, ...)


       XPUSHi  Push an integer onto the stack, extending the
               stack if necessary.  Handles 'set' magic. See
               "PUSHi".

                       void    XPUSHi(IV iv)


       XPUSHn  Push a double onto the stack, extending the stack
               if necessary.  Handles 'set' magic.  See "PUSHn".

                       void    XPUSHn(NV nv)


       XPUSHp  Push a string onto the stack, extending the stack
               if necessary.  The "len" indicates the length of
               the string.  Handles 'set' magic.  See "PUSHp".

                       void    XPUSHp(char* str, STRLEN len)


       XPUSHs  Push an SV onto the stack, extending the stack if
               necessary.  Does not handle 'set' magic.  See
               "PUSHs".

                       void    XPUSHs(SV* sv)


       XPUSHu  Push an unsigned integer onto the stack, extending
               the stack if necessary.  See "PUSHu".

                       void    XPUSHu(UV uv)


       XS      Macro to declare an XSUB and its C parameter list.
               This is handled by "xsubpp".

       XSRETURN
               Return from XSUB, indicating number of items on
               the stack.  This is usually handled by "xsubpp".

                       void    XSRETURN(int nitems)


       XSRETURN_EMPTY
               Return an empty list from an XSUB immediately.

                               XSRETURN_EMPTY;


       XSRETURN_IV
               Return an integer from an XSUB immediately.  Uses
               "XST_mIV".

                       void    XSRETURN_IV(IV iv)


       XSRETURN_NO
               Return "&PL_sv_no" from an XSUB immediately.  Uses
               "XST_mNO".

                               XSRETURN_NO;


       XSRETURN_NV
               Return an double from an XSUB immediately.  Uses
               "XST_mNV".

                       void    XSRETURN_NV(NV nv)


       XSRETURN_PV
               Return a copy of a string from an XSUB immedi­
               ately.  Uses "XST_mPV".

                       void    XSRETURN_PV(char* str)


       XSRETURN_UNDEF
               Return "&PL_sv_undef" from an XSUB immediately.
               Uses "XST_mUNDEF".

                               XSRETURN_UNDEF;


       XSRETURN_YES
               Return "&PL_sv_yes" from an XSUB immediately.
               Uses "XST_mYES".

                               XSRETURN_YES;


       XST_mIV Place an integer into the specified position "pos"
               on the stack.  The value is stored in a new mortal
               SV.

                       void    XST_mIV(int pos, IV iv)


       XST_mNO Place "&PL_sv_no" into the specified position
               "pos" on the stack.

                       void    XST_mNO(int pos)



       XST_mNV Place a double into the specified position "pos"
               on the stack.  The value is stored in a new mortal
               SV.

                       void    XST_mNV(int pos, NV nv)


       XST_mPV Place a copy of a string into the specified posi­
               tion "pos" on the stack.  The value is stored in a
               new mortal SV.

                       void    XST_mPV(int pos, char* str)


       XST_mUNDEF
               Place "&PL_sv_undef" into the specified position
               "pos" on the stack.

                       void    XST_mUNDEF(int pos)


       XST_mYES
               Place "&PL_sv_yes" into the specified position
               "pos" on the stack.

                       void    XST_mYES(int pos)


       XS_VERSION
               The version identifier for an XS module.  This is
               usually handled automatically by "ExtUtils::Make­
               Maker".  See "XS_VERSION_BOOTCHECK".

       XS_VERSION_BOOTCHECK
               Macro to verify that a PM module's $VERSION vari­
               able matches the XS module's "XS_VERSION" vari­
               able.  This is usually handled automatically by
               "xsubpp".  See the The VERSIONCHECK: Keyword entry
               in the perlxs manpage.

                               XS_VERSION_BOOTCHECK;


       Zero    The XSUB-writer's interface to the C "memzero"
               function.  The "dest" is the destination, "nitems"
               is the number of items, and "type" is the type.

                       void    Zero(void* dest, int nitems, type)


AAUUTTHHOORRSS
       Until May 1997, this document was maintained by Jeff
       Okamoto <okamoto@corp.hp.com>.  It is now maintained as
       part of Perl itself.

       With lots of help and suggestions from Dean Roehrich, Mal­
       colm Beattie, Andreas Koenig, Paul Hudson, Ilya Zakhare­
       vich, Paul Marquess, Neil Bowers, Matthew Green, Tim
       Bunce, Spider Boardman, Ulrich Pfeifer, Stephen McCamant,
       and Gurusamy Sarathy.

       API Listing originally by Dean Roehrich
       <roehrich@cray.com>.

       Updated to be autogenerated from comments in the source by
       Benjamin Stuhl.

SSEEEE AALLSSOO
       perlguts(1), perlxs(1), perlxstut(1), perlintern(1)



2001-04-08                 perl v5.6.1                 PERLAPI(1)
