ZSHZLE(1)                                               ZSHZLE(1)



NAME
       zshzle - zsh command line editor

DESCRIPTION
       If the ZLE option is set (which it is by default in inter­
       active shells) and the shell input is attached to the ter­
       minal, the user is able to edit command lines.

       There  are  two display modes.  The first, multiline mode,
       is the default.  It only works if the  TERM  parameter  is
       set  to a valid terminal type that can move the cursor up.
       The second, single line mode, is used if TERM  is  invalid
       or  incapable  of  moving  the  cursor  up, or if the SIN­
       GLE_LINE_ZLE option is set.  This mode is similar to  ksh,
       and  uses  no  termcap sequences.  If TERM is "emacs", the
       ZLE option will be unset by default.

       The parameters BAUD, COLUMNS, and LINES are also  used  by
       the line editor.  See Parameters Used By The Shell in zsh­
       param(1).



KEYMAPS
       A keymap in ZLE contains a set  of  bindings  between  key
       sequences and ZLE commands.  The empty key sequence cannot
       be bound.

       There can be any number of keymaps at any time,  and  each
       keymap  has one or more names.  If all of a keymap's names
       are deleted, it disappears.  bindkey can be used to manip­
       ulate keymap names.

       Initially, there are four keymaps:

       emacs  EMACS emulation
       viins  vi emulation - insert mode
       vicmd  vi emulation - command mode
       .safe  fallback keymap

       The  `.safe'  keymap is special.  It can never be altered,
       and the name can never be removed.   However,  it  can  be
       linked  to  other  names,  which  can  be removed.  In the
       future other special keymaps may be  added;  users  should
       avoid  using  names  beginning  with  `.'  for  their  own
       keymaps.

       In addition to these four names, either `emacs' or `viins'
       is  also  linked to the name `main'.  If one of the VISUAL
       or EDITOR environment variables contain  the  string  `vi'
       when  the  shell starts up then it will be `viins', other­
       wise it will be `emacs'.  bindkey's -e and -v options pro­
       vide a convenient way to override this default choice.

       When  the  editor  starts  up,  it  will select the `main'
       keymap.  If that keymap doesn't exist, it will use `.safe'
       instead.

       In  the  `.safe'  keymap,  each  single  key  is  bound to
       self-insert, except for ^J (line  feed)  and  ^M  (return)
       which  are bound to accept-line.  This is deliberately not
       pleasant to use; if you are using it, it means you deleted
       the main keymap, and you should put it back.

   Reading Commands
       When  ZLE  is  reading a command from the terminal, it may
       read a sequence that is bound to some command and is  also
       a  prefix of a longer bound string.  In this case ZLE will
       wait a certain time to see if more characters  are  typed,
       and if not (or they don't match any longer string) it will
       execute the binding.  This timeout is defined by the  KEY­
       TIMEOUT  parameter;  its  default is 0.4 sec.  There is no
       timeout if the prefix string is not itself bound to a com­
       mand.

       As  well  as  ZLE  commands, key sequences can be bound to
       other  strings,  by  using  `bindkey  -s'.   When  such  a
       sequence is read, the replacement string is pushed back as
       input, and the command reading process starts again  using
       these  fake keystrokes.  This input can itself invoke fur­
       ther replacement strings, but in order to detect loops the
       process  will be stopped if there are twenty such replace­
       ments without a real command being read.


ZLE BUILTINS
       The ZLE module contains three  related  builtin  commands.
       The  bindkey command manipulates keymaps and key bindings;
       the vared command invokes ZLE on  the  value  of  a  shell
       parameter; and the zle command manipulates editing widgets
       and allows command line access to ZLE commands from within
       shell functions.

       bindkey [ options ] -l
       bindkey [ options ] -d
       bindkey [ options ] -D keymap ...
       bindkey [ options ] -A old-keymap new-keymap
       bindkey [ options ] -N new-keymap [ old-keymap ]
       bindkey [ options ] -m
       bindkey [ options ] -r in-string ...
       bindkey [ options ] -s in-string out-string ...
       bindkey [ options ] in-string command ...
       bindkey [ options ] [ in-string ]
              bindkey's  options  can be divided into three cate­
              gories: keymap selection, operation selection,  and
              others.  The keymap selection options are:

              -e     Selects keymap `emacs', and also links it to
                     `main'.

              -v     Selects keymap `viins', and also links it to
                     `main'.

              -a     Selects keymap `vicmd'.

              -M     The  first  non-option argument is used as a
                     keymap name, and does not otherwise count as
                     an argument.

              If  a  keymap selection is required and none of the
              options above are used, the `main' keymap is  used.
              Some  operations  do  not  permit  a  keymap  to be
              selected, namely:

              -l     List all existing keymap names.  If  the  -L
                     option  is  also  used,  list in the form of
                     bindkey commands to create the keymaps.

              -d     Delete all existing keymaps and reset to the
                     default state.

              -D keymap ...
                     Delete the named keymaps.

              -A old-keymap new-keymap
                     Make   the  new-keymap  name  an  alias  for
                     old-keymap, so that both names refer to  the
                     same keymap.  The names have equal standing;
                     if either is deleted, the other remains.  If
                     there   is   already   a   keymap  with  the
                     new-keymap name, it is deleted.

              -N new-keymap [ old-keymap ]
                     Create a new keymap, named new-keymap.  If a
                     keymap already has that name, it is deleted.
                     If an old-keymap  name  is  given,  the  new
                     keymap  is  initialized to be a duplicate of
                     it, otherwise the new keymap will be  empty.

              To  use a newly created keymap, it should be linked
              to main.  Hence the sequence of commands to  create
              and  use  a new keymap `mymap' initialized from the
              emacs keymap (which remains unchanged) is:

                     bindkey -N mymap emacs
                     bindkey -A mymap main

              Note that while `bindkey -A newmap main' will  work
              when newmap is emacs or viins, it will not work for
              vicmd, as switching from vi insert to command  mode
              becomes impossible.

              The  following  operations act on the `main' keymap
              if no keymap selection option was given:

              -m     Add the built-in set of meta-key bindings to
                     the  selected  keymap.   Only  keys that are
                     unbound  or   bound   to   self-insert   are
                     affected.

              -r in-string ...
                     Unbind   the  specified  in-strings  in  the
                     selected keymap.  This is exactly equivalent
                     to binding the strings to undefined-key.

                     When   -R   is   also  used,  interpret  the
                     in-strings as ranges.

                     When -p is also used, the in-strings specify
                     prefixes.   Any  binding  that has the given
                     in-string as a  prefix,  not  including  the
                     binding  for  the  in-string itself, if any,
                     will be removed.  For example,

                             bindkey -rpM viins '^['

                     will remove all bindings  in  the  vi-insert
                     keymap  beginning  with  an escape character
                     (probably cursor keys), but leave the  bind­
                     ing  for the escape character itself (proba­
                     bly vi-cmd-mode).  This is incompatible with
                     the option -R.

              -s in-string out-string ...
                     Bind  each  in-string  to  each  out-string.
                     When in-string is typed, out-string will  be
                     pushed back and treated as input to the line
                     editor.  When -R is also used, interpret the
                     in-strings as ranges.

              in-string command ...
                     Bind  each  in-string to each command.  When
                     -R is  used,  interpret  the  in-strings  as
                     ranges.

              [ in-string ]
                     List key bindings.  If an in-string is spec­
                     ified, the binding of  that  string  in  the
                     selected  keymap  is  displayed.  Otherwise,
                     all key bindings in the selected keymap  are
                     displayed.  (As a special case, if the -e or
                     -v option is used alone, the keymap  is  not
                     displayed  - the implicit linking of keymaps
                     is the only thing that happens.)

                     When the option -p is  used,  the  in-string
                     must  be  present.   The  listing  shows all
                     bindings which have the given  key  sequence
                     as  a prefix, not including any bindings for
                     the key sequence itself.

                     When the -L option is used, the list  is  in
                     the  form  of bindkey commands to create the
                     key bindings.

       When the -R option is used as noted above, a  valid  range
       consists  of  two characters, with an optional `-' between
       them.  All characters between the  two  specified,  inclu­
       sive, are bound as specified.

       For  either  in-string or out-string, the following escape
       sequences are recognised:

       \a     bell character
       \b     backspace
       \e, \E escape
       \f     form feed
       \n     linefeed (newline)
       \r     carriage return
       \t     horizontal tab
       \v     vertical tab
       \NNN   character code in octal
       \xNN   character code in hexadecimal
       \M[-]X character with meta bit set
       \C[-]X control character
       ^X     control character

       In all other cases, `\' escapes the  following  character.
       Delete  is  written  as `^?'.  Note that `\M^?' and `^\M?'
       are not the same, and that (unlike  emacs),  the  bindings
       `\M-X'  and `\eX' are entirely distinct, although they are
       initialized to the same bindings by `bindkey -m'.

       vared [ -Aache ] [ -p prompt ] [ -r rprompt ] name
              The value of the parameter name is loaded into  the
              edit  buffer, and the line editor is invoked.  When
              the editor exits, name is set to the  string  value
              returned by the editor.  When the -c flag is given,
              the parameter is  created  if  it  doesn't  already
              exist.   The -a flag may be given with -c to create
              an array parameter, or the -A  flag  to  create  an
              associative  array.   If  the  type  of an existing
              parameter does not match the type  to  be  created,
              the parameter is unset and recreated.

              If an array or array slice is being edited, separa­
              tor characters as defined in  $IFS  will  be  shown
              quoted  with a backslash, as will backslashes them­
              selves.  Conversely, when the edited text is  split
              into  an  array,  a backslash quotes an immediately
              following  separator  character  or  backslash;  no
              other  special handling of backslashes, or any han­
              dling of quotes, is performed.

              Individual elements of existing array  or  associa­
              tive  array  parameters may be edited by using sub­
              script syntax on name.  New  elements  are  created
              automatically, even without -c.

              If  the -p flag is given, the following string will
              be taken as the prompt to display at the left.   If
              the  -r  flag  is given, the following string gives
              the prompt to display at the right.  If the -h flag
              is specified, the history can be accessed from ZLE.
              If the -e flag is given, typing ^D  (Control-D)  on
              an empty line causes vared to exit immediately with
              a non-zero return value.

       zle -l [ -L | -a ] [ string ... ]
       zle -D widget ...
       zle -A old-widget new-widget
       zle -N widget [ function ]
       zle -C widget completion-widget function
       zle -R [ -c ] [ display-string ] [ string ... ]
       zle -M string
       zle -U string
       zle -I
       zle widget [ -n num ] [ -N ] args ...
       zle    The zle builtin  performs  a  number  of  different
              actions  concerning  ZLE.   Which operation it per­
              forms depends on its options:

              -l [ -L | -a ]
                     List all existing user-defined widgets.   If
                     the  -L  option is used, list in the form of
                     zle commands to create the widgets.

                     When combined with the -a option, all widget
                     names  are  listed,  including  the  builtin
                     ones. In this case the -L option is ignored.

                     If  at  least  one  string is given, nothing
                     will be printed but the return  status  will
                     be zero if all strings are names of existing
                     widgets (or of user-defined widgets  if  the
                     -a  flag  is  not  given) and non-zero if at
                     least one string is not a name of an defined
                     widget.

              -D widget ...
                     Delete the named widgets.

              -A old-widget new-widget
                     Make   the  new-widget  name  an  alias  for
                     old-widget, so that both names refer to  the
                     same widget.  The names have equal standing;
                     if either is deleted, the other remains.  If
                     there  is already a widget with the new-wid­
                     get name, it is deleted.

              -N widget [ function ]
                     Create a user-defined widget.  If  there  is
                     already a widget with the specified name, it
                     is overwritten.   When  the  new  widget  is
                     invoked  from  within the editor, the speci­
                     fied shell function is called.  If no  func­
                     tion  name  is specified, it defaults to the
                     same name as the widget.  For further infor­
                     mation,  see  the  section  Widgets  in zsh­
                     zle(1).

              -C widget completion-widget function
                     Create  a  user-defined  completion   widget
                     named  widget.  The  completion  widget will
                     behave like the  built-in  completion-widget
                     whose name is given as completion-widget. To
                     generate the completions, the shell function
                     function will be called.  For further infor­
                     mation, see zshcompwid(1).

              -R [ -c ] [ display-string ] [ string ... ]
                     Redisplay the command line; this  is  to  be
                     called  from within a user-defined widget to
                     allow changes to become visible.  If a  dis­
                     play-string  is given and not empty, this is
                     shown in the status line (immediately  below
                     the line being edited).

                     If  the  optional strings are given they are
                     listed below the prompt in the same  way  as
                     completion  lists are printed. If no strings
                     are given but the -c option is used  such  a
                     list is cleared.

                     Note  that  this  option  is only useful for
                     widgets that do not exit  immediately  after
                     using  it because the strings displayed will
                     be erased immediately after return from  the
                     widget.

                     This  command  can  safely be called outside
                     user defined widgets; if zle is active,  the
                     display  will  be refreshed, while if zle is
                     not active, the command has no  effect.   In
                     this  case  there  will  usually be no other
                     arguments.  The status is zero  if  zle  was
                     active, else one.

              -M string
                     As  with  the  -R option, the string will be
                     displayed below the command line; unlike the
                     -R  option,  the string will not be put into
                     the status line but will instead be  printed
                     normally  below the prompt.  This means that
                     the string will still be displayed after the
                     widget  returns  (until it is overwritten by
                     subsequent commands).

              -U string
                     This pushes the  characters  in  the  string
                     onto the input stack of ZLE.  After the wid­
                     get currently  executed  finishes  ZLE  will
                     behave  as  if  the characters in the string
                     were typed by the user.

                     As ZLE uses a stack, if this option is  used
                     repeatedly  the  last string pushed onto the
                     stack will be processed first.  However, the
                     characters  in each string will be processed
                     in the order in which  they  appear  in  the
                     string.

              -I     Unusually,  this  option is only useful out­
                     side ordinary widget functions.  It  invali­
                     dates the current zle display in preparation
                     for output; usually this will be from a trap
                     function.   It  has  no effect if zle is not
                     active.  When a trap exits, the shell checks
                     to see if the display needs restoring, hence
                     the following will print output  in  such  a
                     way as not to disturb the line being edited:

                             TRAPUSR1() {
                                 # Invalidate zle display
                               zle -I
                                 # Show output
                               print Hello
                             }

                     Note that there are better ways  of  manipu­
                     lating  the display from within zle widgets.
                     In general, the trap function  may  need  to
                     test whether zle is loaded before using this
                     method; if it is not, there is no  point  in
                     loading  it  specially since the line editor
                     will not be active.

                     The status is zero if zle was  active,  else
                     one.

              widget [ -n num ] [ -N ] args ...
                     Invoke  the specified widget.  This can only
                     be done when ZLE is  active;  normally  this
                     will be within a user-defined widget.

                     With  the  options  -n  and  -N, the current
                     numerical argument will be  saved  and  then
                     restored  after the call to widget; `-n num'
                     sets the numerical argument  temporarily  to
                     num, while `-N' sets it to the default, i.e.
                     as if there were none.

                     Any further arguments will be passed to  the
                     widget.   If  it  is a shell function, these
                     are passed down  as  positional  parameters;
                     for  builtin  widgets it is up to the widget
                     in question what it does  with  them.   Cur­
                     rently  arguments  are  only  handled by the
                     incremental-search   commands,   the    his­
                     tory-search-forward  and  -backward  and the
                     corresponding functions prefixed by vi-, and
                     by  universal-argument.  No error is flagged
                     if the command does not use  the  arguments,
                     or only uses some of them.

                     The  return  status  reflects the success or
                     failure of the operation carried out by  the
                     widget,  or  if  it is a user-defined widget
                     the return status of the shell function.

                     A non-zero return status causes the shell to
                     beep  when the widget exits, unless the BEEP
                     options was unset or the widget  was  called
                     via the zle command.  Thus if a user defined
                     widget requires an immediate beep, it should
                     call the beep widget directly.

       With  no  options and no arguments, only the return status
       will be set. It is zero if ZLE  is  currently  active  and
       widgets  could  be  invoked using this builtin command and
       non-zero if ZLE is not active.


WIDGETS
       All actions in the editor are performed by  `widgets'.   A
       widget's  job is simply to perform some small action.  The
       ZLE commands that key sequences in keymaps  are  bound  to
       are in fact widgets.  Widgets can be user-defined or built
       in.

       The standard widgets built in to ZLE are listed  in  Stan­
       dard Widgets below.  Other built-in widgets can be defined
       by other modules (see zshmodules(1)).  Each built-in  wid­
       get has two names: its normal canonical name, and the same
       name preceded by a `.'.  The `.' name is special: it can't
       be  rebound  to a different widget.  This makes the widget
       available even when its usual name has been redefined.

       User-defined widgets  are  defined  using  `zle  -N',  and
       implemented  as  shell functions.  When the widget is exe­
       cuted, the corresponding shell function is  executed,  and
       can perform editing (or other) actions.  It is recommended
       that user-defined widgets should not have  names  starting
       with `.'.

USER-DEFINED WIDGETS
       User-defined  widgets,  being  implemented  as shell func­
       tions, can execute any normal  shell  command.   They  can
       also  run other widgets (whether built-in or user-defined)
       using the zle builtin command.  The standard input of  the
       function is closed to prevent external commands from unin­
       tentionally blocking ZLE by reading from the terminal, but
       read  -k  or  read  -q  can  be  used  to read characters.
       Finally, they can examine and edit the  ZLE  buffer  being
       edited  by  reading  and  setting  the  special parameters
       described below.

       These special parameters are always  available  in  widget
       functions, but are not in any way special outside ZLE.  If
       they have some normal value outside  ZLE,  that  value  is
       temporarily  inaccessible, but will return when the widget
       function exits.  These special  parameters  in  fact  have
       local  scope,  like parameters created in a function using
       local.

       Inside completion widgets and traps called  while  ZLE  is
       active, these parameters are available read-only.

       BUFFER (scalar)
              The  entire  contents of the edit buffer.  If it is
              written to, the cursor remains at the same  offset,
              unless that would put it outside the buffer.

       BUFFERLINES
              The  number  of  screen  lines  needed for the edit
              buffer currently displayed on screen (i.e.  without
              any  changes to the preceding parameters done after
              the last redisplay).

       CURSOR (integer)
              The offset of the cursor, within the  edit  buffer.
              This is in the range 0 to $#BUFFER, and is by defi­
              nition equal to $#LBUFFER.  Attempts  to  move  the
              cursor outside the buffer will result in the cursor
              being moved to the appropriate end of the buffer.

       HISTNO (integer)
              The current history number.

       KEYS (scalar)
              The keys typed to invoke this widget, as a  literal
              string.

       LASTWIDGET (scalar)
              The name of the last widget that was executed.

       LBUFFER (scalar)
              The part of the buffer that lies to the left of the
              cursor position.  If it is assigned to,  only  that
              part  of  the  buffer  is  replaced, and the cursor
              remains  between  the  new  $LBUFFER  and  the  old
              $RBUFFER.

       MARK (integer)
              Like CURSOR, but for the mark.

       NUMERIC (integer)
              The  numeric  argument.  If no numeric argument was
              given, this parameter is unset. When  this  is  set
              inside  a  widget  function, builtin widgets called
              with the zle builtin command  will  use  the  value
              assigned.  If it is unset inside a widget function,
              builtin widgets called  behave  as  if  no  numeric
              argument was given.

       PENDING (integer)
              The  number  of  bytes  pending for input, i.e. the
              number of bytes which have already been  typed  and
              can immediately be read. On systems where the shell
              is not able to get this information, this parameter
              will always have a value of zero.

       PREBUFFER (scalar)
              In a multi-line input at the secondary prompt, this
              read-only parameter contains the  contents  of  the
              lines before the one the cursor is currently in.

       RBUFFER (scalar)
              The  part  of  the buffer that lies to the right of
              the cursor position.  If it is  assigned  to,  only
              that part of the buffer is replaced, and the cursor
              remains  between  the  old  $LBUFFER  and  the  new
              $RBUFFER.

       WIDGET (scalar)
              The name of the widget currently being executed.

STANDARD WIDGETS
       The  following  is a list of all the standard widgets, and
       their default bindings in emacs mode, vi command mode  and
       vi  insert mode (the `emacs', `vicmd' and `viins' keymaps,
       respectively).

       Note that cursor keys are bound to movement  keys  in  all
       three keymaps; the shell assumes that the cursor keys send
       the  key  sequences  reported  by  the   terminal-handling
       library (termcap or terminfo).  The key sequences shown in
       the list are those based on the VT100, common on many mod­
       ern  terminals,  but  in  fact  these  are not necessarily
       bound.  In the case  of  the  viins  keymap,  the  initial
       escape character of the sequences serves also to return to
       the vicmd keymap: whether this happens  is  determined  by
       the KEYTIMEOUT parameter, see zshparam(1).

   Movement
       vi-backward-blank-word (unbound) (B) (unbound)
              Move  backward one word, where a word is defined as
              a series of non-blank characters.

       backward-char (^B ESC-[D) (unbound) (unbound)
              Move backward one character.

       vi-backward-char (unbound) (^H h ^?) (ESC-[D)
              Move  backward  one  character,  without   changing
              lines.

       backward-word (ESC-B ESC-b) (unbound) (unbound)
              Move to the beginning of the previous word.

       emacs-backward-word
              Move to the beginning of the previous word.

       vi-backward-word (unbound) (b) (unbound)
              Move   to  the  beginning  of  the  previous  word,
              vi-style.

       beginning-of-line (^A) (unbound) (unbound)
              Move to the beginning of the line.  If  already  at
              the beginning of the line, move to the beginning of
              the previous line, if any.

       vi-beginning-of-line
              Move to the beginning of the line, without changing
              lines.

       end-of-line (^E) (unbound) (unbound)
              Move to the end of the line.  If already at the end
              of the line, move to the end of the next  line,  if
              any.

       vi-end-of-line (unbound) ($) (unbound)
              Move  to  the  end  of the line.  If an argument is
              given to this command, the cursor will be moved  to
              the end of the line (argument - 1) lines down.

       vi-forward-blank-word (unbound) (W) (unbound)
              Move forward one word, where a word is defined as a
              series of non-blank characters.

       vi-forward-blank-word-end (unbound) (E) (unbound)
              Move to the end of the current word, or, if at  the
              end  of  the  current  word, to the end of the next
              word, where a  word  is  defined  as  a  series  of
              non-blank characters.

       forward-char (^F ESC-[C) (unbound) (unbound)
              Move forward one character.

       vi-forward-char (unbound) (space l) (ESC-[C)
              Move forward one character.

       vi-find-next-char (^X^F) (f) (unbound)
              Read a character from the keyboard, and move to the
              next occurrence of it in the line.

       vi-find-next-char-skip (unbound) (t) (unbound)
              Read a character from the keyboard, and move to the
              position  just  before the next occurrence of it in
              the line.

       vi-find-prev-char (unbound) (F) (unbound)
              Read a character from the keyboard, and move to the
              previous occurrence of it in the line.

       vi-find-prev-char-skip (unbound) (T) (unbound)
              Read a character from the keyboard, and move to the
              position just after the previous occurrence  of  it
              in the line.

       vi-first-non-blank (unbound) (^) (unbound)
              Move  to the first non-blank character in the line.

       vi-forward-word (unbound) (w) (unbound)
              Move forward one word, vi-style.

       forward-word (ESC-F ESC-f) (unbound) (unbound)
              Move to the beginning of the next word.   The  edi­
              tor's  idea  of  a word is specified with the WORD­
              CHARS parameter.

       emacs-forward-word
              Move to the end of the next word.

       vi-forward-word-end (unbound) (e) (unbound)
              Move to the end of the next word.

       vi-goto-column (ESC-|) (|) (unbound)
              Move to the column specified by the  numeric  argu­
              ment.

       vi-goto-mark (unbound) (`) (unbound)
              Move to the specified mark.

       vi-goto-mark-line (unbound) (') (unbound)
              Move to beginning of the line containing the speci­
              fied mark.

       vi-repeat-find (unbound) (;) (unbound)
              Repeat the last vi-find command.

       vi-rev-repeat-find (unbound) (,) (unbound)
              Repeat the last vi-find  command  in  the  opposite
              direction.

   History Control
       beginning-of-buffer-or-history (ESC-<) (unbound) (unbound)
              Move  to the beginning of the buffer, or if already
              there, move to the first event in the history list.

       beginning-of-line-hist
              Move  to  the beginning of the line.  If already at
              the beginning of the buffer, move to  the  previous
              history line.

       beginning-of-history
              Move to the first event in the history list.

       down-line-or-history (^N ESC-[B) (j) (ESC-[B)
              Move  down  a  line in the buffer, or if already at
              the bottom line, move to the next event in the his­
              tory list.

       vi-down-line-or-history (unbound) (+) (unbound)
              Move  down  a  line in the buffer, or if already at
              the bottom line, move to the next event in the his­
              tory  list.  Then move to the first non-blank char­
              acter on the line.

       down-line-or-search
              Move down a line in the buffer, or  if  already  at
              the  bottom line, search forward in the history for
              a line beginning with the first word in the buffer.

              If  called  from a function by the zle command with
              arguments, the  first  argument  is  taken  as  the
              string  for  which to search, rather than the first
              word in the buffer.

       down-history (unbound) (^N) (unbound)
              Move to the next event in the history list.

       history-beginning-search-backward
              Search backward in the history for a line beginning
              with  the  current  line  up  to  the cursor.  This
              leaves the cursor in its original position.

       end-of-buffer-or-history (ESC->) (unbound) (unbound)
              Move to the end of the buffer, or if already there,
              move to the last event in the history list.

       end-of-line-hist
              Move to the end of the line.  If already at the end
              of the buffer, move to the next history line.

       end-of-history
              Move to the last event in the history list.

       vi-fetch-history (unbound) (G) (unbound)
              Fetch the history line  specified  by  the  numeric
              argument.   This  defaults  to  the current history
              line (i.e. the one that isn't history yet).

       history-incremental-search-backward  (^R  ^Xr)   (unbound)
       (unbound)
              Search  backward  incrementally  for  a   specified
              string.   The  search  is  case-insensitive  if the
              search string does not have uppercase  letters  and
              no  numeric  argument  was  given.   The string may
              begin with `^' to anchor the search to  the  begin­
              ning of the line.

              A  restricted set of editing functions is available
              in  the  mini-buffer.   An  interrupt  signal,   as
              defined  by  the stty setting, will stop the search
              and go back to the original line.  An undefined key
              will  have the same effect. The supported functions
              are: backward-delete-char, vi-backward-delete-char,
              clear-screen,       redisplay,       quoted-insert,
              vi-quoted-insert,                  accept-and-hold,
              accept-and-infer-next-history,    accept-line   and
              accept-line-and-down-history.

              magic-space just inserts a space.  vi-cmd-mode tog­
              gles  between  the  `main' and `vicmd' keymaps; the
              `main' keymap (insert mode) will be  selected  ini­
              tially.   history-incremental-search-backward  will
              get the next occurrence  of  the  contents  of  the
              mini-buffer.     history-incremental-search-forward
              inverts the sense of the search.   vi-repeat-search
              and  vi-rev-repeat-search  are similarly supported.
              The direction of the search  is  indicated  in  the
              mini-buffer.

              Any multi-character string that is not bound to one
              of the above functions will beep and interrupt  the
              search,  leaving the last found line in the buffer.
              Any single character that is not bound  to  one  of
              the    above    functions,    or   self-insert   or
              self-insert-unmeta, will have the same  effect  but
              the function will be executed.

              When  called from a widget function by the zle com­
              mand, the incremental search commands  can  take  a
              string  argument.  This will be treated as a string
              of keys, as for arguments to the  bindkey  command,
              and  used  as  initial  input for the command.  Any
              characters in the string which are  unused  by  the
              incremental  search  will be silently ignored.  For
              example,

                     zle history-incremental-search-backward forceps

              will search  backwards  for  forceps,  leaving  the
              minibuffer containing the string `forceps'.

       history-incremental-search-forward   (^S   ^Xs)  (unbound)
       (unbound)
              Search   forward   incrementally  for  a  specified
              string.  The  search  is  case-insensitive  if  the
              search  string  does not have uppercase letters and
              no numeric argument  was  given.   The  string  may
              begin  with  `^' to anchor the search to the begin­
              ning of the line.  The functions available  in  the
              mini-buffer  are  the same as for history-incremen­
              tal-search-backward.

       history-search-backward (ESC-P ESC-p) (unbound) (unbound)
              Search backward in the history for a line beginning
              with the first word in the buffer.

              If  called  from a function by the zle command with
              arguments, the  first  argument  is  taken  as  the
              string  for  which to search, rather than the first
              word in the buffer.

       vi-history-search-backward (unbound) (/) (unbound)
              Search backward in  the  history  for  a  specified
              string.   The  string  may begin with `^' to anchor
              the search to the beginning of the line.

              A restricted set of editing functions is  available
              in   the  mini-buffer.   An  interrupt  signal,  as
              defined by the stty setting,  will stop the search.
              The  functions  available  in  the mini-buffer are:
              accept-line,     backward-delete-char,     vi-back­
              ward-delete-char,    backward-kill-word,   vi-back­
              ward-kill-word,      clear-screen,       redisplay,
              quoted-insert and vi-quoted-insert.

              vi-cmd-mode is treated the same as accept-line, and
              magic-space is treated as a space.  Any other char­
              acter   that   is   not  bound  to  self-insert  or
              self-insert-unmeta will beep and be ignored. If the
              function  is called from vi command mode, the bind­
              ings of the current insert mode will be used.

              If called from a function by the zle  command  with
              arguments,  the  first  argument  is  taken  as the
              string for which to search, rather than  the  first
              word in the buffer.

       history-search-forward (ESC-N ESC-n) (unbound) (unbound)
              Search  forward in the history for a line beginning
              with the first word in the buffer.

              If called from a function by the zle  command  with
              arguments,  the  first  argument  is  taken  as the
              string for which to search, rather than  the  first
              word in the buffer.

       vi-history-search-forward (unbound) (?) (unbound)
              Search  forward  in  the  history  for  a specified
              string.  The string may begin with  `^'  to  anchor
              the  search to the beginning of the line. The func­
              tions available in the mini-buffer are the same  as
              for  vi-history-search-backward.  Argument handling
              is also the same as for that command.

       infer-next-history (^X^N) (unbound) (unbound)
              Search in the history list for a line matching  the
              current one and fetch the event following it.

       insert-last-word (ESC-_ ESC-.) (unbound) (unbound)
              Insert  the  last  word  from  the previous history
              event  at  the  cursor  position.   If  a  positive
              numeric  argument  is  given, insert that word from
              the end of the  previous  history  event.   If  the
              argument  is zero or negative insert that word from
              the left (zero inserts the previous command  word).
              Repeating  this  command  replaces  the  word  just
              inserted with the last word from the history  event
              prior  to  the one just used; numeric arguments can
              be used in the same way to pick a  word  from  that
              event.

       vi-repeat-search (unbound) (n) (unbound)
              Repeat the last vi history search.

       vi-rev-repeat-search (unbound) (N) (unbound)
              Repeat  the last vi history search, but in reverse.

       up-line-or-history (^P ESC-[A) (k) (ESC-[A)
              Move up a line in the buffer, or if already at  the
              top line, move to the previous event in the history
              list.

       vi-up-line-or-history (unbound) (-) (unbound)
              Move up a line in the buffer, or if already at  the
              top line, move to the previous event in the history
              list.  Then move to the first  non-blank  character
              on the line.

       up-line-or-search
              Move  up a line in the buffer, or if already at the
              top line, search backward in the history for a line
              beginning with the first word in the buffer.

              If  called  from a function by the zle command with
              arguments, the  first  argument  is  taken  as  the
              string  for  which to search, rather than the first
              word in the buffer.

       up-history (unbound) (^P) (unbound)
              Move to the previous event in the history list.

       history-beginning-search-forward
              Search forward in the history for a line  beginning
              with  the  current  line  up  to  the cursor.  This
              leaves the cursor in its original position.

   Modifying Text
       vi-add-eol (unbound) (A) (unbound)
              Move to the end of the line and enter insert  mode.

       vi-add-next (unbound) (a) (unbound)
              Enter  insert  mode  after the current cursor posi­
              tion, without changing lines.

       backward-delete-char (^H ^?) (unbound) (unbound)
              Delete the character behind the cursor.

       vi-backward-delete-char (unbound) (X) (^H)
              Delete the character  behind  the  cursor,  without
              changing  lines.   If  in  insert  mode, this won't
              delete past the point where insert  mode  was  last
              entered.

       backward-delete-word
              Delete the word behind the cursor.

       backward-kill-line
              Kill  from  the beginning of the line to the cursor
              position.

       backward-kill-word (^W ESC-^H ESC-^?) (unbound) (unbound)
              Kill the word behind the cursor.

       vi-backward-kill-word (unbound) (unbound) (^W)
              Kill the word behind the cursor, without going past
              the point where insert mode was last entered.

       capitalize-word (ESC-C ESC-c) (unbound) (unbound)
              Capitalize the current word and move past it.

       vi-change (unbound) (c) (unbound)
              Read a movement command from the keyboard, and kill
              from the cursor position to  the  endpoint  of  the
              movement.   Then enter insert mode.  If the command
              is vi-change, change the current line.

       vi-change-eol (unbound) (C) (unbound)
              Kill to the end of the line and enter insert  mode.

       vi-change-whole-line (unbound) (S) (unbound)
              Kill the current line and enter insert mode.

       copy-region-as-kill (ESC-W ESC-w) (unbound) (unbound)
              Copy  the  area  from the cursor to the mark to the
              kill buffer.

       copy-prev-word (ESC-^_) (unbound) (unbound)
              Duplicate the word to the left of the cursor.

       copy-prev-shell-word (ESC-^_) (unbound) (unbound)
              Like copy-prev-word, but the word is found by using
              shell  parsing,  whereas  copy-prev-word  looks for
              blanks. This makes a difference when  the  word  is
              quoted and contains spaces.

       vi-delete (unbound) (d) (unbound)
              Read a movement command from the keyboard, and kill
              from the cursor position to  the  endpoint  of  the
              movement.   If  the  command is vi-delete, kill the
              current line.

       delete-char
              Delete the character under the cursor.

       vi-delete-char (unbound) (x) (unbound)
              Delete the  character  under  the  cursor,  without
              going past the end of the line.

       delete-word
              Delete the current word.

       down-case-word (ESC-L ESC-l) (unbound) (unbound)
              Convert  the current word to all lowercase and move
              past it.

       kill-word (ESC-D ESC-d) (unbound) (unbound)
              Kill the current word.

       gosmacs-transpose-chars
              Exchange the two characters behind the cursor.

       vi-indent (unbound) (>) (unbound)
              Indent a number of lines.

       vi-insert (unbound) (i) (unbound)
              Enter insert mode.

       vi-insert-bol (unbound) (I) (unbound)
              Move to the first non-blank character on  the  line
              and enter insert mode.

       vi-join (^X^J) (J) (unbound)
              Join the current line with the next one.

       kill-line (^K) (unbound) (unbound)
              Kill  from  the  cursor to the end of the line.  If
              already on the end of the line,  kill  the  newline
              character.

       vi-kill-line (unbound) (unbound) (^U)
              Kill  from  the cursor back to wherever insert mode
              was last entered.

       vi-kill-eol (unbound) (D) (unbound)
              Kill from the cursor to the end of the line.

       kill-region
              Kill from the cursor to the mark.

       kill-buffer (^X^K) (unbound) (unbound)
              Kill the entire buffer.

       kill-whole-line (^U) (unbound) (unbound)
              Kill the current line.

       vi-match-bracket (^X^B) (%) (unbound)
              Move to the bracket character (one of {}, () or [])
              that matches the one under the cursor.  If the cur­
              sor is not on a  bracket  character,  move  forward
              without going past the end of the line to find one,
              and then go to the matching bracket.

       vi-open-line-above (unbound) (O) (unbound)
              Open a line above the cursor and enter insert mode.

       vi-open-line-below (unbound) (o) (unbound)
              Open a line below the cursor and enter insert mode.

       vi-oper-swap-case
              Read a movement command from the keyboard, and swap
              the case of all characters from the cursor position
              to the endpoint of the movement.  If  the  movement
              command  is vi-oper-swap-case, swap the case of all
              characters on the current line.

       overwrite-mode (^X^O) (unbound) (unbound)
              Toggle between overwrite mode and insert mode.

       vi-put-before (unbound) (P) (unbound)
              Insert the contents of the kill buffer  before  the
              cursor.   If the kill buffer contains a sequence of
              lines (as opposed to characters),  paste  it  above
              the current line.

       vi-put-after (unbound) (p) (unbound)
              Insert  the  contents  of the kill buffer after the
              cursor.  If the kill buffer contains a sequence  of
              lines  (as  opposed  to characters), paste it below
              the current line.

       quoted-insert (^V) (unbound) (unbound)
              Insert the next character  typed  into  the  buffer
              literally.   An  interrupt  character  will  not be
              inserted.

       vi-quoted-insert (unbound) (unbound) (^Q ^V)
              Display a `^' at the cursor  position,  and  insert
              the next character typed into the buffer literally.
              An interrupt character will not be inserted.

       quote-line (ESC-') (unbound) (unbound)
              Quote the current line; that is, put a `''  charac­
              ter  at  the beginning and the end, and convert all
              `'' characters to `'\'''.

       quote-region (ESC-") (unbound) (unbound)
              Quote the region from the cursor to the mark.

       vi-replace (unbound) (R) (unbound)
              Enter overwrite mode.

       vi-repeat-change (unbound) (.) (unbound)
              Repeat the last vi mode text  modification.   If  a
              count   was  used  with  the  modification,  it  is
              remembered.  If a count is given to  this  command,
              it  overrides  the  remembered count, and is remem­
              bered for future uses of  this  command.   The  cut
              buffer specification is similarly remembered.

       vi-replace-chars (unbound) (r) (unbound)
              Replace the character under the cursor with a char­
              acter read from the keyboard.

       self-insert (printable  characters)  (unbound)  (printable
       characters and some control characters)
              Insert a character into the buffer  at  the  cursor
              position.

       self-insert-unmeta   (ESC-^I   ESC-^J   ESC-^M)  (unbound)
       (unbound)
              Insert  a character into the buffer after stripping
              the meta bit and converting ^M to ^J.

       vi-substitute (unbound) (s) (unbound)
              Substitute the next character(s).

       vi-swap-case (unbound) (~) (unbound)
              Swap the case of the character under the cursor and
              move past it.

       transpose-chars (^T) (unbound) (unbound)
              Exchange the two characters to the left of the cur­
              sor if at end of line, else exchange the  character
              under the cursor with the character to the left.

       transpose-words (ESC-T ESC-t) (unbound) (unbound)
              Exchange the current word with the one before it.

       vi-unindent (unbound) (<) (unbound)
              Unindent a number of lines.

       up-case-word (ESC-U ESC-u) (unbound) (unbound)
              Convert  the current word to all caps and move past
              it.

       yank (^Y) (unbound) (unbound)
              Insert the contents of the kill buffer at the  cur­
              sor position.

       yank-pop (ESC-y) (unbound) (unbound)
              Remove  the text just yanked, rotate the kill-ring,
              and yank the new top.  Only works following yank or
              yank-pop.

       vi-yank (unbound) (y) (unbound)
              Read a movement command from the keyboard, and copy
              the region from the cursor position to the endpoint
              of  the movement into the kill buffer.  If the com­
              mand is vi-yank, copy the current line.

       vi-yank-whole-line (unbound) (Y) (unbound)
              Copy the current line into the kill buffer.

       vi-yank-eol
              Copy the region from the cursor position to the end
              of  the  line into the kill buffer.  Arguably, this
              is what Y should do in vi, but  it  isn't  what  it
              actually does.

   Arguments
       digit-argument (ESC-0..ESC-9) (1-9) (unbound)
              Start a new numeric argument, or add to the current
              one.  See also vi-digit-or-beginning-of-line.  This
              only  works  if bound to a key sequence ending in a
              decimal digit.

              Inside a widget function, a call to  this  function
              treats  the  last  key  of  the  key sequence which
              called the widget as the digit.

       neg-argument (ESC--) (unbound) (unbound)
              Changes the sign of the following argument.

       universal-argument
              Multiply the argument of the  next  command  by  4.
              Alternatively,  if  this  command is followed by an
              integer (positive or negative),  use  that  as  the
              argument  for the next command.  Thus digits cannot
              be repeated using this command.   For  example,  if
              this  command occurs twice, followed immediately by
              forward-char,  move  forward  sixteen  spaces;   if
              instead  it  is  followed by -2, then forward-char,
              move backward two spaces.

              Inside a widget function, if  passed  an  argument,
              i.e.  `zle  universal-argument  num', the numerical
              argument will be set to num; this is equivalent  to
              `NUMERIC=num'.

   Completion
       accept-and-menu-complete
              In a menu completion, insert the current completion
              into the buffer, and advance to the  next  possible
              completion.

       complete-word
              Attempt completion on the current word.

       delete-char-or-list (^D) (unbound) (unbound)
              Delete the character under the cursor.  If the cur­
              sor is at the end of the line, list  possible  com­
              pletions for the current word.

       expand-cmd-path
              Expand the current command to its full pathname.

       expand-or-complete (TAB) (unbound) (TAB)
              Attempt  shell  expansion  on the current word.  If
              that fails, attempt completion.

       expand-or-complete-prefix
              Attempt shell expansion on the current word  up  to
              cursor.

       expand-history (ESC-space ESC-!) (unbound) (unbound)
              Perform history expansion on the edit buffer.

       expand-word (^X*) (unbound) (unbound)
              Attempt shell expansion on the current word.

       list-choices (ESC-^D) (^D =) (^D)
              List possible completions for the current word.

       list-expand (^Xg ^XG) (^G) (^G)
              List the expansion of the current word.

       magic-space
              Perform  history  expansion and insert a space into
              the buffer.  This is intended to be bound to space.

       menu-complete
              Like  complete-word, except that menu completion is
              used.  See the MENU_COMPLETE option.

       menu-expand-or-complete
              Like expand-or-complete, except that  menu  comple­
              tion is used.

       reverse-menu-complete
              Perform menu completion, like menu-complete, except
              that if a menu completion is already  in  progress,
              move  to  the  previous  completion rather than the
              next.

       end-of-list
              When a previous completion displayed a  list  below
              the  prompt,  this  widget  can be used to move the
              prompt below the list.

   Miscellaneous
       accept-and-hold (ESC-A ESC-a) (unbound) (unbound)
              Push the contents of the buffer on the buffer stack
              and execute it.

       accept-and-infer-next-history
              Execute  the  contents  of the buffer.  Then search
              the history list for a line  matching  the  current
              one  and  push  the event following onto the buffer
              stack.

       accept-line (^J ^M) (^J ^M) (^J ^M)
              Finish editing the buffer.   Normally  this  causes
              the buffer to be executed as a shell command.

       accept-line-and-down-history (^O) (unbound) (unbound)
              Execute the current line, and push the next history
              event on the the buffer stack.

       beep   Beep, unless the BEEP option is unset.

       vi-cmd-mode (^X^V) (unbound) (^[)
              Enter command mode; that  is,  select  the  `vicmd'
              keymap.   Yes,  this  is  bound by default in emacs
              mode.

       vi-caps-lock-panic
              Hang until any lowercase key is pressed.   This  is
              for  vi  users  without the mental capacity to keep
              track of their caps lock key (like the author).

       clear-screen (^L ESC-^L) (^L) (^L)
              Clear the screen and redraw the prompt.

       describe-key-briefly
              Reads a key  sequence,  then  prints  the  function
              bound to that sequence.

       exchange-point-and-mark (^X^X) (unbound) (unbound)
              Exchange  the  cursor position with the position of
              the mark.

       execute-named-cmd (ESC-x) (unbound) (unbound)
              Read the name of an editor command and execute  it.
              A  restricted set of editing functions is available
              in  the  mini-buffer.   An  interrupt  signal,   as
              defined  by  the stty setting, will abort the func­
              tion.   The   allowed    functions    are:    back­
              ward-delete-char,          vi-backward-delete-char,
              clear-screen,       redisplay,       quoted-insert,
              vi-quoted-insert,    backward-kill-word,   vi-back­
              ward-kill-word,   kill-whole-line,    vi-kill-line,
              backward-kill-line,                   list-choices,
              delete-char-or-list,  complete-word,   accept-line,
              expand-or-complete and expand-or-complete-prefix.

              kill-region kills the last word, and vi-cmd-mode is
              treated the same as accept-line.  The space and tab
              characters, if not bound to one of these functions,
              will complete the name and then list the possibili­
              ties  if  the  AUTO_LIST  option is set.  Any other
              character that  is  not  bound  to  self-insert  or
              self-insert-unmeta  will  beep and be ignored.  The
              bindings of the current insert mode will be used.

       execute-last-named-cmd (ESC-z) (unbound) (unbound)
              Redo  the  last   function   executed   with   exe­
              cute-named-cmd.

       get-line (ESC-G ESC-g) (unbound) (unbound)
              Pop the top line off the buffer stack and insert it
              at the cursor position.

       pound-insert (unbound) (#) (unbound)
              If there is no # character at the beginning of  the
              buffer,  add one to the beginning of each line.  If
              there is one, remove a # from each  line  that  has
              one.  In either case, accept the current line.  The
              INTERACTIVE_COMMENTS option must be set for this to
              have any usefulness.

       vi-pound-insert
              If  there is no # character at the beginning of the
              current line, add one.  If there is one, remove it.
              The  INTERACTIVE_COMMENTS  option  must  be set for
              this to have any usefulness.

       push-input
              Push the entire current  multiline  construct  onto
              the  buffer stack and return to the top-level (PS1)
              prompt.  If the current parser construct is only  a
              single  line, this is exactly like push-line.  Next
              time  the  editor  starts  up  or  is  popped  with
              get-line,  the construct will be popped off the top
              of the buffer stack and  loaded  into  the  editing
              buffer.

       push-line (^Q ESC-Q ESC-q) (unbound) (unbound)
              Push  the  current buffer onto the buffer stack and
              clear the buffer.  Next time the editor starts  up,
              the buffer will be popped off the top of the buffer
              stack and loaded into the editing buffer.

       push-line-or-edit
              At  the  top-level  (PS1)  prompt,  equivalent   to
              push-line.   At  a secondary (PS2) prompt, move the
              entire current multiline construct into the  editor
              buffer.   The  latter  is  equivalent to push-input
              followed by get-line.

       redisplay (unbound) (^R) (^R)
              Redisplays the edit buffer.

       send-break (^G ESC-^G) (unbound) (unbound)
              Abort  the  current  editor  function,  e.g.   exe­
              cute-named-command,  or  the editor itself, e.g. if
              you are in vared. Otherwise abort  the  parsing  of
              the current line.

       run-help (ESC-H ESC-h) (unbound) (unbound)
              Push  the buffer onto the buffer stack, and execute
              the command `run-help cmd', where cmd is  the  cur­
              rent command.  run-help is normally aliased to man.

       vi-set-buffer (unbound) (") (unbound)
              Specify a buffer to be used in the  following  com­
              mand.   There are 35 buffers that can be specified:
              the 26 `named'  buffers  "a  to  "z  and  the  nine
              `queued'  buffers  "1 to "9.  The named buffers can
              also be specified as "A to "Z.

              When a buffer is specified for a cut  command,  the
              text  being  cut  replaces the previous contents of
              the specified buffer.  If a named buffer is  speci­
              fied  using  a  capital,  the  newly  cut  text  is
              appended to the buffer instead of overwriting it.

              If no buffer is specified for a cut command, "1  is
              used, and the contents of "1 to "8 are each shifted
              along one buffer; the contents of "9 is lost.

       vi-set-mark (unbound) (m) (unbound)
              Set the specified mark at the cursor position.

       set-mark-command (^@) (unbound) (unbound)
              Set the mark at the cursor position.

       spell-word (ESC-$ ESC-S ESC-s) (unbound) (unbound)
              Attempt spelling correction on the current word.

       undefined-key
              This command is executed when a key  sequence  that
              is  not  bound to any command is typed.  By default
              it beeps.

       undo (^_ ^Xu ^X^U) (unbound) (unbound)
              Incrementally undo the last text modification.

       redo   Incrementally redo undone text modifications.

       vi-undo-change (unbound) (u) (unbound)
              Undo the last text modification.  If repeated, redo
              the modification.

       what-cursor-position (^X=) (unbound) (unbound)
              Print  the  character under the cursor, its code as
              an octal, decimal and hexadecimal number, the  cur­
              rent cursor position within the buffer and the col­
              umn of the cursor in the current line.

       where-is
              Read the name of an editor command  and  and  print
              the listing of key sequences that invoke the speci­
              fied command.

       which-command (ESC-?) (unbound) (unbound)
              Push the buffer onto the buffer stack, and  execute
              the  command  `which-command cmd'. where cmd is the
              current command.  which-command is normally aliased
              to whence.

       vi-digit-or-beginning-of-line (unbound) (0) (unbound)
              If the last command executed was a digit as part of
              an argument,  continue  the  argument.   Otherwise,
              execute vi-beginning-of-line.



zsh 4.0.4                October 26, 2001               ZSHZLE(1)
